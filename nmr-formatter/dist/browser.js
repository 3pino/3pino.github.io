// Browser-compatible bundle for NMR Formatter
// Auto-generated by scripts/build-browser.js
// DO NOT EDIT THIS FILE MANUALLY - It will be overwritten on build

// ========== CORE & MODELS ==========
// Centralized logging utility
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["DEBUG"] = 0] = "DEBUG";
    LogLevel[LogLevel["INFO"] = 1] = "INFO";
    LogLevel[LogLevel["WARN"] = 2] = "WARN";
    LogLevel[LogLevel["ERROR"] = 3] = "ERROR";
    LogLevel[LogLevel["NONE"] = 4] = "NONE";
})(LogLevel || (LogLevel = {}));
class Logger {
    static setLogLevel(level) {
        this.logLevel = level;
    }
    static debug(message, ...args) {
        if (this.logLevel <= LogLevel.DEBUG) {
            console.log(`[DEBUG] ${message}`, ...args);
        }
    }
    static info(message, ...args) {
        if (this.logLevel <= LogLevel.INFO) {
            console.info(`[INFO] ${message}`, ...args);
        }
    }
    static warn(message, ...args) {
        if (this.logLevel <= LogLevel.WARN) {
            console.warn(`[WARN] ${message}`, ...args);
        }
    }
    static error(message, ...args) {
        if (this.logLevel <= LogLevel.ERROR) {
            console.error(`[ERROR] ${message}`, ...args);
        }
    }
}
Logger.logLevel = LogLevel.INFO;

// Configuration constants for nuclei and solvents
// Nuclei preset configurations
const NUCLEI_PRESETS = [
    { id: "1H", displayHTML: "<sup>1</sup>H", pattern: /(¹H|protone?|1H\s+NMR|NMR\s+1H)/i },
    { id: "2H", displayHTML: "<sup>2</sup>H", pattern: /(²H|deuterium|2H\s+NMR|NMR\s+2H)/i },
    { id: "13C", displayHTML: "<sup>13</sup>C", pattern: /(13C|¹³C|carbon)/i },
    { id: "14N", displayHTML: "<sup>14</sup>N", pattern: /(14N|¹⁴N)/i },
    { id: "15N", displayHTML: "<sup>15</sup>N", pattern: /(15N|¹⁵N)/i },
    { id: "19F", displayHTML: "<sup>19</sup>F", pattern: /(19F|¹⁹F)/i },
    { id: "23Na", displayHTML: "<sup>23</sup>Na", pattern: /(23Na|²³Na)/i },
    { id: "27Al", displayHTML: "<sup>27</sup>Al", pattern: /(27Al|²⁷Al)/i },
    { id: "29Si", displayHTML: "<sup>29</sup>Si", pattern: /(29Si|²⁹Si)/i },
    { id: "31P", displayHTML: "<sup>31</sup>P", pattern: /(31P|³¹P)/i }
];
// Solvent preset configurations
const SOLVENT_PRESETS = [
    { id: "D2O", displayHTML: "D<sub>2</sub>O", pattern: /([DH][2₂]O|water)/i },
    { id: "CD3OD", displayHTML: "CD<sub>3</sub>OD", pattern: /(C[DH][3₃]O[DH]|methanol)/i },
    { id: "CD3CN", displayHTML: "CD<sub>3</sub>CN", pattern: /(C[DH][3₃]CN|acetonitrile?)/i },
    { id: "(CD3)2SO", displayHTML: "DMSO–<I>d</I><sub>6</sub>", pattern: /(\(C[DH][3₃]\)[2₂]SO|Me[2₂]SO|DMSO)/i },
    { id: "(CD3)2CO", displayHTML: "acetone–<I>d</I><sub>6</sub>", pattern: /(\(C[DH][3₃]\)[2₂]CO|Me[2₂]CO|acetone?)/i },
    { id: "C6D6", displayHTML: "C<sub>6</sub>D<sub>6</sub>", pattern: /(C[6₆][DH][6₆]|benzene?)/i },
    { id: "toluene-d8", displayHTML: "toluene–<i>d</i><sub>8</sub>", pattern: /(toluene?)/i },
    { id: "CDCl3", displayHTML: "CDCl<sub>3</sub>", pattern: /(C[DH]Cl[3₃]|ch?loroform)/i },
    { id: "CD2Cl2", displayHTML: "CD<sub>2</sub>Cl<sub>2</sub>", pattern: /(C[DH][2₂]Cl[2₂]|dich?loromethane?)/i },
    { id: "THF-d8", displayHTML: "THF–<i>d</i><sub>8</sub>", pattern: /(THF|tetrahydrofuran)/i }
];
// Sort order preset configurations
const SORT_ORDER_PRESETS = [
    { id: "desc", displayHTML: "Descending", pattern: /desc/i },
    { id: "asc", displayHTML: "Ascending", pattern: /asc/i }
];
// Legacy Record-based configurations (for backward compatibility)
const NUCLEI_CONFIG = {
    "1H": /(¹H|protone?|1H\s+NMR|NMR\s+1H)/i,
    "2H": /(²H|deuterium|2H\s+NMR|NMR\s+2H)/i,
    "13C": /(13C|¹³C|carbon)/i,
    "14N": /(14N|¹⁴N)/i,
    "15N": /(15N|¹⁵N)/i,
    "19F": /(19F|¹⁹F)/i,
    "23Na": /(23Na|²³Na)/i,
    "27Al": /(27Al|²⁷Al)/i,
    "29Si": /(29Si|²⁹Si)/i,
    "31P": /(31P|³¹P)/i,
    "": null
};
const SOLVENT_CONFIG = {
    "D2O": /([DH][2₂]O|water)/i,
    "CD3OD": /(C[DH][3₃]O[DH]|methanol)/i,
    "CD3CN": /(C[DH][3₃]CN|acetonitrile?)/i,
    "(CD3)2SO": /(\(C[DH][3₃]\)[2₂]SO|Me[2₂]SO|DMSO)/i,
    "(CD3)2CO": /(\(C[DH][3₃]\)[2₂]CO|Me[2₂]CO|acetone?)/i,
    "C6D6": /(C[6₆][DH][6₆]|benzene?)/i,
    "toluene-d8": /(toluene?)/i,
    "CDCl3": /(C[DH]Cl[3₃]|ch?loroform)/i,
    "CD2Cl2": /(C[DH][2₂]Cl[2₂]|dich?loromethane?)/i,
    "THF-d8": /(THF|tetrahydrofuran)/i,
    "": null
};
// Utility functions for pattern access
function getNucleiPatterns() {
    const patterns = {};
    for (const [nuclei, pattern] of Object.entries(NUCLEI_CONFIG)) {
        if (pattern && nuclei !== "") {
            patterns[nuclei] = pattern;
        }
    }
    return patterns;
}
function getSolventPatterns() {
    const patterns = {};
    for (const [solvent, pattern] of Object.entries(SOLVENT_CONFIG)) {
        if (pattern && solvent !== "") {
            patterns[solvent] = pattern;
        }
    }
    return patterns;
}
// Type-safe extraction functions
function extractNucleiFromText(text) {
    for (const preset of NUCLEI_PRESETS) {
        if (preset.pattern.test(text)) {
            return preset.id;
        }
    }
    return "";
}
function extractSolventFromText(text) {
    for (const preset of SOLVENT_PRESETS) {
        if (preset.pattern.test(text)) {
            return preset.id;
        }
    }
    return "";
}
function extractNucleiHTMLFromText(text) {
    for (const preset of NUCLEI_PRESETS) {
        if (preset.pattern.test(text)) {
            return preset.displayHTML;
        }
    }
    return "";
}
function extractSolventHTMLFromText(text) {
    for (const preset of SOLVENT_PRESETS) {
        if (preset.pattern.test(text)) {
            return preset.displayHTML;
        }
    }
    return "";
}
// Type safety validation functions
function isValidNucleiType(value) {
    return NUCLEI_PRESETS.some(preset => preset.id === value) || value === "";
}
function isValidSolventType(value) {
    return SOLVENT_PRESETS.some(preset => preset.id === value) || value === "";
}

// Metadata model for NMR data
class Metadata {
    constructor(nuclei = "", solvent = "", frequency = 0) {
        this.nuclei = nuclei;
        this.solvent = solvent;
        this.frequency = frequency;
    }
}
// Runtime validation functions
function validateNucleiType(nuclei) {
    if (isValidNucleiType(nuclei)) {
        return nuclei;
    }
    Logger.warn(`Invalid nuclei type: ${nuclei}. Falling back to empty string.`);
    return "";
}
function validateSolventType(solvent) {
    if (isValidSolventType(solvent)) {
        return solvent;
    }
    Logger.warn(`Invalid solvent type: ${solvent}. Falling back to empty string.`);
    return "";
}

// NMR Peak model
class NMRPeak {
    constructor(chemicalShift = 0, multiplicity = "", jValues = [], integration = 0, assignment = "") {
        this.chemicalShift = chemicalShift;
        this.multiplicity = multiplicity;
        this.jValues = jValues;
        this.integration = integration;
        this.assignment = assignment;
    }
    // Convenience getter/setter for compatibility with app.js
    get shift() {
        return typeof this.chemicalShift === 'number' ? this.chemicalShift : this.chemicalShift[0];
    }
    set shift(value) {
        this.chemicalShift = value;
    }
    /**
     * Get expected number of J-values based on multiplicity
     * Returns null for singlet(s), multiplet(m), or broad(br)
     * Returns array of expected J-value counts for compound multiplicities (e.g., dt -> [2,3])
     */
    static multipletnumbers(multiplicityText) {
        const clean = multiplicityText.toLowerCase().trim();
        let normalized = clean;
        const replacementMap = [
            [/\s+of\s+/g, ' '],
            [/[\s\-–()]+/g, ' '],
            [/broad\s*/g, ''],
            [/br\s*/g, ''],
            // Full words - keep s and m
            [/nonets?/g, '9'],
            [/octets?/g, '8'],
            [/septets?/g, '7'],
            [/sextets?/g, '6'],
            [/quintets?/g, '5'],
            [/quartets?/g, '4'],
            [/triplets?/g, '3'],
            [/doublets?/g, '2'],
            [/singlets?/g, 's'],
            [/multiplets?/g, 'm'],
            // Abbreviations - keep s and m
            [/non(?!et)/g, '9'],
            [/oct(?!et)/g, '8'],
            [/sept(?!et)/g, '7'],
            [/sext(?!et)/g, '6'],
            [/quint(?!et)/g, '5'],
            [/q(?!u)/g, '4'],
            [/t(?!r|e)/g, '3'],
            [/d(?!o)/g, '2'],
            [/s(?!i)/g, 's'],
            [/m(?!u)/g, 'm'],
            [/b(?!r|o)/g, ''],
            [/\s+/g, ''],
        ];
        replacementMap.forEach(([pattern, replacement]) => {
            normalized = normalized.replace(pattern, replacement);
        });
        normalized = normalized.trim();
        // Validate s/m combinations
        if (/s/.test(normalized) || /m/.test(normalized)) {
            // Check for invalid s patterns
            if (/[sm][sm]/.test(normalized)) {
                throw new Error(`Invalid multiplicity combination: "${multiplicityText}" (multiple s / m)`);
            }
            if (/s\d|\ds/.test(normalized)) {
                throw new Error(`Invalid multiplicity combination: "${multiplicityText}" (s cannot combine with other multiplicities)`);
            }
            // Check for invalid m patterns
            if (/\dm/.test(normalized)) {
                throw new Error(`Invalid multiplicity combination: "${multiplicityText}" (m must be at the beginning)`);
            }
            // Single s or m is OK
            if (normalized === 's' || normalized === 'm') {
                return null;
            }
            // m + digits is OK (e.g., "m23" from "m(dt)")
            if (/^m\d+$/.test(normalized)) {
                const digits = normalized.match(/\d/g);
                if (digits && digits.length > 0) {
                    return digits.map(d => parseInt(d, 10));
                }
            }
            // If we reach here, it's an invalid s/m combination
            throw new Error(`Invalid multiplicity combination: "${multiplicityText}"`);
        }
        if (normalized === '')
            return null;
        const digits = normalized.match(/\d/g);
        if (digits && digits.length > 0) {
            return digits.map(d => parseInt(d, 10));
        }
        throw new Error(`Unhandled multiplicity format: "${multiplicityText}"`);
    }
    /**
     * Check if J-values are optional for a given multiplicity
     * Returns true if multiplicity contains 'm', 'br', or 'broad' (e.g., "m(tt)", "br d", "bs")
     */
    static isJValuesOptional(multiplicityText) {
        const clean = multiplicityText.toLowerCase().trim();
        // Check if contains m/br/broad
        const hasBroadOrMultiplet = /\b(m|multiplet|br|broad)\b|^b/.test(clean);
        if (!hasBroadOrMultiplet) {
            return false; // No m/br/broad → not optional
        }
        // If it's ONLY m/br/broad (no other multiplicity), return false
        // because J-values must be 0 (handled by multipletnumbers returning null)
        const jCounts = NMRPeak.multipletnumbers(multiplicityText);
        if (jCounts === null) {
            return false; // Only m/br/broad → J-values must be 0, not optional
        }
        // Has both m/br/broad AND other multiplicity → optional
        return true;
    }
    /**
     * Validate this peak's J-value count against multiplicity
     */
    validate() {
        const errors = [];
        // Validate Integration: must be >= 0.5
        if (this.integration !== null && this.integration !== '') {
            const integrationValue = typeof this.integration === 'string'
                ? parseFloat(this.integration)
                : this.integration;
            if (!isNaN(integrationValue) && integrationValue < 0.5) {
                errors.push({
                    type: 'peak',
                    index: 0,
                    field: 'integration',
                    message: `Integration must be at least 0.5, but found ${integrationValue}`
                });
            }
        }
        if (this.multiplicity) {
            try {
                const expectedJCounts = NMRPeak.multipletnumbers(this.multiplicity);
                if (expectedJCounts !== null) {
                    const actualJCount = this.jValues.filter((j) => !isNaN(j) && j > 0).length;
                    const expectedTotal = expectedJCounts.length;
                    // Check if J-values are optional (e.g., "m(tt)", "br d")
                    const isOptional = NMRPeak.isJValuesOptional(this.multiplicity);
                    // If optional: allow 0 or expectedTotal J-values
                    // If not optional: must have exactly expectedTotal J-values
                    if (!isOptional && actualJCount !== expectedTotal) {
                        errors.push({
                            type: 'peak',
                            index: 0,
                            field: 'jcount',
                            message: `Multiplicity "${this.multiplicity}" expects ${expectedTotal} J-values, but found ${actualJCount}`
                        });
                    }
                    else if (isOptional && actualJCount !== 0 && actualJCount !== expectedTotal) {
                        errors.push({
                            type: 'peak',
                            index: 0,
                            field: 'jcount',
                            message: `Multiplicity "${this.multiplicity}" expects 0 or ${expectedTotal} J-values, but found ${actualJCount}`
                        });
                    }
                }
            }
            catch (error) {
                // Invalid multiplicity format - ignore as it's not our concern
            }
        }
        return errors;
    }
}

// NMR Data model
class NMRData {
    constructor(peaks = [], metadata = new Metadata()) {
        this.peaks = peaks;
        this.metadata = metadata;
    }
    addPeak(peak) {
        this.peaks.push(peak);
    }
    removePeak(index) {
        if (index >= 0 && index < this.peaks.length) {
            this.peaks.splice(index, 1);
        }
    }
    updateMetadata(key, value) {
        this.metadata[key] = value;
    }
    /**
     * Validate all peaks in this NMR data
     */
    validate() {
        const errors = [];
        if (!this.peaks) {
            return [];
        }
        // Validate each peak (only J-value and multiplicity consistency)
        this.peaks.forEach((peak, index) => {
            const peakErrors = peak.validate();
            // Update index in errors
            peakErrors.forEach(error => {
                errors.push(Object.assign(Object.assign({}, error), { index }));
            });
        });
        return errors;
    }
}

/**
 * Utility functions for data parsing and conversion
 */
/**
 * Parse chemical shift string to number or range
 * Supports formats: "7.53", "7.53-7.50", "7.53–7.50"
 */
function parseChemicalShift(value) {
    if (!value || value.trim() === '')
        return null;
    const trimmed = value.trim();
    // Check for range format (supports both hyphen and en-dash)
    const rangeMatch = trimmed.match(/^([\d.]+)\s*[-–]\s*([\d.]+)$/);
    if (rangeMatch) {
        const num1 = parseFloat(rangeMatch[1]);
        const num2 = parseFloat(rangeMatch[2]);
        if (!isNaN(num1) && !isNaN(num2)) {
            return [num1, num2];
        }
    }
    // Single value
    const num = parseFloat(trimmed);
    if (!isNaN(num)) {
        return num;
    }
    return null;
}
/**
 * Convert multiplicity input to text format
 * Supports numeric shorthand: "1" -> "s", "23" -> "dt", etc.
 */
function convertMultiplicityToText(input) {
    if (!input || input.trim() === '')
        return '';
    const trimmed = input.trim();
    // Check if input is purely numeric
    if (/^\d+$/.test(trimmed)) {
        const digitMap = {
            '1': 's',
            '2': 'd',
            '3': 't',
            '4': 'q',
            '5': 'quint'
        };
        let result = '';
        for (const digit of trimmed) {
            if (digit >= '1' && digit <= '5') {
                result += digitMap[digit];
            }
        }
        return result;
    }
    return trimmed;
}
/**
 * Calculate required J-value columns based on multiplicity
 */
function calculateRequiredJColumns(multiplicity) {
    if (!multiplicity || multiplicity.trim() === '') {
        return 0;
    }
    try {
        const jCounts = NMRPeak.multipletnumbers(multiplicity);
        // Validate return value
        if (jCounts === null || !Array.isArray(jCounts)) {
            return 0;
        }
        return jCounts.length;
    }
    catch (error) {
        console.error('Error calculating J columns:', error);
        return 0;
    }
}

/**
 * Utility functions for sorting NMR data
 */
/**
 * Sort peaks array by chemical shift value
 */
function sortPeaksByShift(peaks, order) {
    peaks.sort((a, b) => {
        const aValue = getShiftValue(a.chemicalShift);
        const bValue = getShiftValue(b.chemicalShift);
        if (order === 'asc') {
            return aValue - bValue;
        }
        else {
            return bValue - aValue;
        }
    });
}
/**
 * Get numeric value from chemical shift (average for ranges)
 */
function getShiftValue(shift) {
    if (Array.isArray(shift)) {
        return (shift[0] + shift[1]) / 2;
    }
    return shift;
}

/**
 * Utility functions for validating NMR data
 */
/**
 * Validate metadata fields
 * @returns true if there are errors
 */
function validateMetadata(metadata, validationState) {
    let hasErrors = false;
    if (!metadata.nuclei || metadata.nuclei.trim() === '') {
        validationState.setError('nuclei', 'Nuclei is required');
        hasErrors = true;
    }
    if (!metadata.solvent || metadata.solvent.trim() === '') {
        validationState.setError('solvent', 'Solvent is required');
        hasErrors = true;
    }
    if (!metadata.frequency || metadata.frequency === 0) {
        validationState.setError('frequency', 'Frequency is required');
        hasErrors = true;
    }
    return hasErrors;
}
/**
 * Validate a single table row
 * @returns true if there are errors
 */
function validateTableRow(row, is1HNMR, validationState) {
    let hasErrors = false;
    const rowId = row.id;
    // Validate chemical shift using field validator
    const shiftResult = shiftValidator.validate(row.shift);
    if (!shiftResult.isValid) {
        validationState.setError(`shift-${rowId}`, shiftResult.errorMessage || 'Invalid chemical shift');
        hasErrors = true;
    }
    else {
        validationState.clearError(`shift-${rowId}`);
    }
    // Validate multiplicity using field validator
    const multResult = multiplicityValidator.validate(row.multiplicity, { is1HNMR });
    if (!multResult.isValid) {
        validationState.setError(`mult-${rowId}`, multResult.errorMessage || 'Invalid multiplicity');
        hasErrors = true;
    }
    else {
        validationState.clearError(`mult-${rowId}`);
    }
    // Validate integration using field validator
    const intResult = integrationValidator.validate(row.integration, { is1HNMR });
    if (!intResult.isValid) {
        validationState.setError(`int-${rowId}`, intResult.errorMessage || 'Invalid integration');
        hasErrors = true;
    }
    else {
        validationState.clearError(`int-${rowId}`);
    }
    // Validate J-values using field validator
    const multiplicity = convertMultiplicityToText(row.multiplicity);
    let requiredJCount = 0;
    try {
        const jCounts = NMRPeak.multipletnumbers(multiplicity);
        requiredJCount = (jCounts === null || jCounts === void 0 ? void 0 : jCounts.length) || 0;
    }
    catch (error) {
        // Invalid multiplicity - skip J-value validation
    }
    for (let i = 0; i < requiredJCount; i++) {
        const jResult = jValueValidator.validate(row.jValues[i] || 0, {
            multiplicity: row.multiplicity,
            jIndex: i,
            allJValues: row.jValues
        });
        if (!jResult.isValid) {
            validationState.setError(`j${i}-${rowId}`, jResult.errorMessage || 'Invalid J-value');
            hasErrors = true;
        }
        else {
            validationState.clearError(`j${i}-${rowId}`);
        }
    }
    // Clear errors for J-values beyond required count
    for (let i = requiredJCount; i < row.jValues.length; i++) {
        validationState.clearError(`j${i}-${rowId}`);
    }
    return hasErrors;
}
/**
 * Validate all table rows
 * @returns true if there are errors
 */
function validateTableRows(rows, is1HNMR, validationState) {
    let hasErrors = false;
    rows.forEach(row => {
        if (validateTableRow(row, is1HNMR, validationState)) {
            hasErrors = true;
        }
    });
    return hasErrors;
}

// NMR Formatter
// Converts structured NMRData objects into HTML-formatted academic text
// Helper function to format chemical shift values with significant figures
function formatChemicalShift(shift, significantFigures = 3) {
    if (Array.isArray(shift)) {
        // Range format with en-dash
        return `${formatSignificantFigures(shift[0], significantFigures)}–${formatSignificantFigures(shift[1], significantFigures)}`;
    }
    return formatSignificantFigures(shift, significantFigures);
}
// Helper function to format number with significant figures
function formatSignificantFigures(num, sigFigs) {
    if (num === 0)
        return '0';
    // Get the magnitude (order of 10)
    const magnitude = Math.floor(Math.log10(Math.abs(num)));
    // Calculate decimal places needed for the significant figures
    const decimalPlaces = Math.max(0, sigFigs - magnitude - 1);
    return num.toFixed(decimalPlaces);
}
// Helper function to format J-values with italics and significant figures
function formatJValues(jValues, significantFigures = 2) {
    if (jValues.length === 0)
        return "";
    const jString = jValues.map(j => formatSignificantFigures(j, significantFigures)).join(", ");
    return ` <I>J</I> = ${jString} Hz`;
}
function formatIntegration(integration, decimalPlaces = 1, nuclei = "1H") {
    // Handle empty/zero values
    if (integration === 0 || integration === "" || integration === null || integration === undefined) {
        return "";
    }
    // Check if integration rounds to 0 or less (< 0.5)
    if (typeof integration === "number" && Math.round(integration) <= 0) {
        return "";
    }
    // Extract the atom symbol from nuclei (e.g., "1H" -> "H", "13C" -> "C", "<sup>1</sup>H" -> "H")
    const nucleiText = nuclei.replace(/<[^>]+>/g, ""); // Remove HTML tags
    const atomSymbol = nucleiText.replace(/\d+/g, "") || "H"; // Remove all numbers
    // Handle string integration values
    if (typeof integration === "string") {
        const trimmed = integration.trim();
        if (trimmed === "")
            return "";
        // Try to parse as number for decimal formatting
        const parsed = parseFloat(trimmed);
        if (!isNaN(parsed)) {
            if (parsed === 0)
                return "";
            return `, ${parsed.toFixed(decimalPlaces)}${atomSymbol}`;
        }
        // If it's already formatted (contains atom symbols), return as is with comma
        if (/[A-Z]/.test(trimmed)) {
            return trimmed.startsWith(',') ? trimmed : `, ${trimmed}`;
        }
        // Otherwise, treat as raw integration string and add atom symbol
        return `, ${trimmed}${atomSymbol}`;
    }
    // Handle number integration values with precise decimal formatting
    if (integration === 0)
        return "";
    return `, ${integration.toFixed(decimalPlaces)}${atomSymbol}`;
}
// Helper function to format multiplicity
function formatMultiplicity(multiplicity) {
    if (!multiplicity)
        return "";
    return multiplicity;
}
// Helper function to format assignment
function formatAssignment(assignment) {
    if (!assignment || assignment.trim() === "")
        return "";
    return assignment.trim();
}
// Helper function to format a single peak
function formatSinglePeak(peak, shiftSigFigs = 3, jValueSigFigs = 2, integrationDecimalPlaces = 0, nuclei = "1H") {
    const shift = formatChemicalShift(peak.chemicalShift, shiftSigFigs);
    const mult = formatMultiplicity(peak.multiplicity);
    const jValues = formatJValues(peak.jValues, jValueSigFigs);
    const integration = formatIntegration(peak.integration, integrationDecimalPlaces, nuclei);
    const assignment = formatAssignment(peak.assignment);
    // Build the peak string: δ shift (multiplicity, J-values, integration, assignment)
    let peakStr = shift;
    if (mult || jValues || integration || assignment) {
        peakStr += " (";
        const parts = [];
        if (mult)
            parts.push(mult);
        if (jValues)
            parts.push(jValues.trim());
        if (integration)
            parts.push(integration.replace(", ", ""));
        if (assignment)
            parts.push(assignment);
        peakStr += parts.join(", ");
        peakStr += ")";
    }
    return peakStr;
}
// Helper function to format metadata section
function formatMetadata(metadata) {
    const parts = [];
    // Nuclei with superscript
    if (metadata.nuclei) {
        let nucleiFormatted = metadata.nuclei;
        // Apply superscript formatting for nuclei numbers
        nucleiFormatted = nucleiFormatted.replace(/^(\d+)/, "<sup>$1</sup>");
        parts.push(`${nucleiFormatted} NMR`);
    }
    // Solvent with subscript formatting
    if (metadata.solvent) {
        let solventFormatted = metadata.solvent;
        // Apply subscript formatting for numbers in solvent names
        solventFormatted = solventFormatted.replace(/(\d+)/g, "<sub>$1</sub>");
        parts.push(`(${solventFormatted}`);
    }
    // Frequency
    if (metadata.frequency && !isNaN(metadata.frequency)) {
        const frequencyInt = Math.round(metadata.frequency);
        const freqPart = parts.length > 1 ? `, ${frequencyInt} MHz)` : `(${frequencyInt} MHz)`;
        if (parts.length > 1) {
            parts[parts.length - 1] += freqPart;
        }
        else {
            parts.push(freqPart);
        }
    }
    else if (metadata.solvent) {
        // Close the solvent parentheses if no frequency
        parts[parts.length - 1] += ")";
    }
    return parts.join(" ");
}
// Main formatting function
function generateFormattedText(data, shiftSigFigs = 3, jValueSigFigs = 2, integrationDecimalPlaces = 0) {
    var _a;
    if (!data || !data.peaks || data.peaks.length === 0) {
        return "";
    }
    Logger.debug('Formatting NMR data:', data);
    const result = [];
    // Add metadata section
    const metadataStr = formatMetadata(data.metadata);
    if (metadataStr) {
        result.push(metadataStr);
    }
    // Add delta symbol and peaks
    const nuclei = ((_a = data.metadata) === null || _a === void 0 ? void 0 : _a.nuclei) || "1H";
    // Filter out peaks with integration < 0.5 (rounds to 0)
    const filteredPeaks = data.peaks.filter(peak => {
        if (typeof peak.integration === 'number') {
            return Math.round(peak.integration) > 0;
        }
        return true; // Keep string integrations
    });
    const peakStrings = filteredPeaks.map(peak => formatSinglePeak(peak, shiftSigFigs, jValueSigFigs, integrationDecimalPlaces, nuclei));
    const peaksSection = "δ " + peakStrings.join(", ");
    result.push(peaksSection);
    // Join with space
    const formattedText = result.join(" ");
    Logger.debug('Generated formatted text:', formattedText);
    return formattedText;
}

/**
 * TSV (Tab-Separated Values) parser utilities
 */
/**
 * Check if the given text contains TSV data
 * TSV is detected if the text contains at least one tab or newline character
 * @param text - Text to check
 * @returns True if text contains tab or newline
 */
function isTSVData(text) {
    return text.includes('\t') || text.includes('\n');
}
/**
 * Parse TSV data into a 2D array
 * @param text - TSV text to parse
 * @returns 2D array of cell values
 */
function parseTSV(text) {
    // Normalize line endings
    const normalized = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n');
    // Split by lines
    const lines = normalized.split('\n');
    // Parse each line by tabs
    return lines.map(line => line.split('\t'));
}

/**
 * TopSpin data parser utilities
 * Handles parsing of Bruker TopSpin NMR data files
 */
/**
 * Internal helper: Find the first valid TopSpin directory from the given files
 * @param files - Array of files to check
 * @returns Object containing the directory path and the three required files, or null if not found
 */
function findTopSpinDirectory(files) {
    const requiredFiles = ['integrals.txt', 'parm.txt', 'peaklist.xml'];
    // Extract directory path from file path
    // File.webkitRelativePath gives us the full path for dropped directories
    const getDirectoryPath = (file) => {
        const path = file.webkitRelativePath || file.name;
        const lastSlash = Math.max(path.lastIndexOf('/'), path.lastIndexOf('\\'));
        return lastSlash >= 0 ? path.substring(0, lastSlash) : '';
    };
    // Group files by directory path
    const filesByDirectory = new Map();
    for (const file of files) {
        const dirPath = getDirectoryPath(file);
        const fileName = file.name;
        if (!filesByDirectory.has(dirPath)) {
            filesByDirectory.set(dirPath, new Map());
        }
        filesByDirectory.get(dirPath).set(fileName, file);
    }
    // Find first directory with all three required files
    for (const [dirPath, fileMap] of filesByDirectory.entries()) {
        const hasAllRequired = requiredFiles.every(required => fileMap.has(required));
        if (hasAllRequired) {
            console.log("TopSpin directory found:", dirPath);
            return {
                dirPath,
                integralFile: fileMap.get('integrals.txt'),
                parmFile: fileMap.get('parm.txt'),
                peaklistFile: fileMap.get('peaklist.xml')
            };
        }
    }
    return null;
}
/**
 * Check if the given files contain TopSpin data
 * TopSpin data is identified by the presence of specific files like peaklist.xml and acqus
 * @param files - Array of files to check
 * @returns True if files contain TopSpin data structure
 */
function isTopSpinData(files) {
    return findTopSpinDirectory(files) !== null;
}
/**
 * Parse TopSpin directory structure and extract NMR peaks
 * @param files - Array of files from TopSpin directory
 * @returns Array of parsed NMR peaks
 */
async function parseTopSpinDirectory(files) {
    const topspinDir = findTopSpinDirectory(files);
    if (!topspinDir) {
        throw new Error('TopSpin data not found in provided files');
    }
    // Read all three files asynchronously
    const [integralContent, parmContent, peaklistContent] = await Promise.all([
        topspinDir.integralFile.text(),
        topspinDir.parmFile.text(),
        topspinDir.peaklistFile.text()
    ]);
    // Parse all three files
    const integrals = parseIntegrals(integralContent);
    const chemicalShifts = parseTopSpinXML(peaklistContent);
    const metadata = parseTopSpinMetadata(parmContent);
    // Extract frequency (default to 1 if not found, to avoid breaking the calculation)
    const frequency = metadata.frequency || 1;
    // Create NMRPeak objects by matching F1 values to integration ranges
    const peaks = [];
    for (const integral of integrals) {
        // Find F1 values within this integration range
        const min = Math.min(integral.rangeStart, integral.rangeEnd);
        const max = Math.max(integral.rangeStart, integral.rangeEnd);
        const f1InRange = chemicalShifts.filter(f1 => f1 >= min && f1 <= max);
        // Calculate shift (chemical shift position)
        let shift;
        if (f1InRange.length === 0) {
            // No F1 values found, use average of integration range
            shift = (integral.rangeStart + integral.rangeEnd) / 2;
        }
        else if (f1InRange.length % 2 === 1) {
            // Odd number: use median (middle value)
            const sorted = [...f1InRange].sort((a, b) => a - b);
            shift = sorted[Math.floor(sorted.length / 2)];
        }
        else {
            // Even number: use average of two middle values
            const sorted = [...f1InRange].sort((a, b) => a - b);
            const mid = sorted.length / 2;
            shift = (sorted[mid - 1] + sorted[mid]) / 2;
        }
        // Calculate multiplicity
        const multiplicity = getMultiplicityLabel(f1InRange.length);
        // Calculate J-values (pass frequency for Hz conversion)
        const jValues = calculateJValues(f1InRange, frequency);
        // Create NMRPeak object
        const peak = new NMRPeak(shift, multiplicity, jValues, integral.integral, '' // assignment is empty
        );
        peaks.push(peak);
    }
    return peaks;
}
/**
 * Parse TopSpin XML peaklist file into NMR peaks
 * @param xmlContent - Content of peaklist.xml file
 * @returns Array of parsed NMR peaks
 */
function parseTopSpinXML(xmlContent) {
    const chemicalShifts = [];
    // Use regex to extract all F1 attribute values from Peak1D elements
    // Pattern: <Peak1D F1="value" .../>
    const peak1DPattern = /<Peak1D\s+F1="([\d.]+)"/g;
    let match;
    while ((match = peak1DPattern.exec(xmlContent)) !== null) {
        const f1Value = parseFloat(match[1]);
        if (!isNaN(f1Value)) {
            chemicalShifts.push(f1Value);
        }
    }
    return chemicalShifts;
}
/**
 * Parse TopSpin acqus file to extract metadata
 * @param acqusContent - Content of acqus parameter file
 * @returns Partial metadata object with nuclei, solvent, and frequency
 */
/**
 * Parse integrals.txt to extract integration ranges and values
 * @param integralsContent - Content of integrals.txt file
 * @returns Array of integration data with range and value
 */
function parseIntegrals(integralsContent) {
    const integrals = [];
    const lines = integralsContent.split('\n');
    for (const line of lines) {
        const trimmedLine = line.trim();
        // Skip header lines and empty lines
        if (!trimmedLine || trimmedLine.startsWith('Current') ||
            trimmedLine.startsWith('NAME') || trimmedLine.startsWith('DU') ||
            trimmedLine.startsWith('Number')) {
            continue;
        }
        // Parse line format: "Number   Start   End   Integral"
        // Example: "    1      8.591      8.549         2.21014"
        const parts = trimmedLine.split(/\s+/);
        if (parts.length >= 4) {
            const rangeStart = parseFloat(parts[1]);
            const rangeEnd = parseFloat(parts[2]);
            const integral = parseFloat(parts[3]);
            if (!isNaN(rangeStart) && !isNaN(rangeEnd) && !isNaN(integral)) {
                integrals.push({ rangeStart, rangeEnd, integral });
            }
        }
    }
    return integrals;
}
/**
 * Calculate multiplicity label from number of F1 peaks
 * @param count - Number of F1 peaks in the integration range
 * @returns Multiplicity label (s, d, t, q, etc., or m for many)
 */
function getMultiplicityLabel(count) {
    if (count === 0)
        return 's';
    if (count >= 10)
        return 'm';
    return count.toString();
}
/**
 * Calculate J-coupling value from F1 peak distribution
 * @param f1Values - Array of F1 values in the integration range (in ppm)
 * @param frequency - NMR frequency in MHz
 * @returns J-coupling value in Hz, or empty array if not applicable
 */
function calculateJValues(f1Values, frequency) {
    if (f1Values.length < 2 || f1Values.length >= 10) {
        return [];
    }
    // Calculate (max - min) / (count - 1)
    const min = Math.min(...f1Values);
    const max = Math.max(...f1Values);
    const jValue = (max - min) / (f1Values.length - 1) * frequency;
    return [jValue];
}
function parseTopSpinMetadata(parmContent) {
    const metadata = {};
    // Split into lines
    const lines = parmContent.split('\n');
    for (const line of lines) {
        const trimmedLine = line.trim();
        // Extract SOLVENT (format: "SOLVENT            DMSO")
        if (trimmedLine.startsWith('SOLVENT')) {
            const parts = trimmedLine.split(/\s+/);
            if (parts.length >= 2) {
                const solventText = parts[1];
                const solvent = extractSolventHTMLFromText(solventText);
                if (solvent) {
                    metadata.solvent = solvent;
                }
            }
        }
        // Extract SFO1 (format: "SFO1        500.1730885 MHz")
        if (trimmedLine.startsWith('SFO1')) {
            const parts = trimmedLine.split(/\s+/);
            if (parts.length >= 2) {
                const frequency = parseFloat(parts[1]);
                if (!isNaN(frequency)) {
                    metadata.frequency = frequency;
                }
            }
        }
        // Extract NUC1 (format: "NUC1                 1H")
        if (trimmedLine.startsWith('NUC1')) {
            const parts = trimmedLine.split(/\s+/);
            if (parts.length >= 2) {
                const nucleiText = parts[1];
                const nuclei = extractNucleiHTMLFromText(nucleiText);
                if (nuclei) {
                    metadata.nuclei = nuclei;
                }
            }
        }
    }
    return metadata;
}

// ========== VALIDATORS ==========
/**
 * Input filtering utilities for real-time input restriction
 * These functions filter user input to prevent invalid characters from being entered
 */
/**
 * Filter numeric input to allow only digits and one decimal point
 * Used for J-values and Integration fields
 * @param value - The input value to filter
 * @returns Filtered value containing only digits and at most one decimal point
 * @example
 * filterNumericInput("12.34.56") // "12.3456"
 * filterNumericInput("abc123") // "123"
 * filterNumericInput("1.2.3") // "1.23"
 */
function filterNumericInput(value) {
    // Remove all non-numeric characters except decimal point
    let filtered = value.replace(/[^0-9.]/g, '');
    // Allow only one decimal point
    const parts = filtered.split('.');
    if (parts.length > 2) {
        filtered = parts[0] + '.' + parts.slice(1).join('');
    }
    return filtered;
}
/**
 * Filter chemical shift input to allow numbers, decimal points, and range indicators
 * Used for Chemical Shift (δ) field which can be a single value or a range
 * Allows: digits, decimal points, minus sign (-), en dash (–), negative numbers
 * @param value - The input value to filter
 * @returns Filtered value for chemical shift input
 * @example
 * filterChemicalShiftInput("7.25-7.30") // "7.25-7.30"
 * filterChemicalShiftInput("7.25–7.30") // "7.25–7.30"
 * filterChemicalShiftInput("-1.5") // "-1.5"
 * filterChemicalShiftInput("abc7.25") // "7.25"
 */
function filterChemicalShiftInput(value) {
    // Allow: digits (0-9), decimal point (.), hyphen-minus (-), en dash (–)
    return value.replace(/[^0-9.\-–]/g, '');
}
/**
 * Filter HTML content to allow only specific tags
 * Used for Assignment field to restrict rich text formatting
 * @param container - DOM element containing HTML to filter
 * @param allowedTags - Array of uppercase tag names to allow (e.g., ['B', 'I', 'SUB', 'SUP'])
 * @returns Filtered HTML string
 */
function filterHTMLTags(container, allowedTags) {
    const clone = container.cloneNode(true);
    const allElements = clone.querySelectorAll('*');
    allElements.forEach(el => {
        var _a;
        if (!allowedTags.includes(el.tagName)) {
            // Replace disallowed element with its text content
            const textNode = document.createTextNode(el.textContent || '');
            (_a = el.parentNode) === null || _a === void 0 ? void 0 : _a.replaceChild(textNode, el);
        }
    });
    return clone.innerHTML;
}
/**
 * No filtering - allows any input
 * Used for Chemical Shift and Multiplicity fields
 * @param value - The input value
 * @returns Unmodified value
 */
function noFilter(value) {
    return value;
}

/**
 * Field-level validation logic
 * Each validator provides input filtering and validation rules for a specific field type
 */
/**
 * Chemical Shift validator
 */
const shiftValidator = {
    filterInput: noFilter,
    validate: (value) => {
        const strValue = typeof value === 'number' ? value.toString() : value;
        if (!strValue || strValue.trim() === '') {
            return { isValid: false, errorMessage: 'Chemical shift is required' };
        }
        const parsed = parseChemicalShift(strValue);
        if (parsed === null) {
            return { isValid: false, errorMessage: 'Invalid chemical shift' };
        }
        return { isValid: true };
    }
};
/**
 * Multiplicity validator
 * @param context.is1HNMR - Whether this is 1H NMR (multiplicity required)
 */
const multiplicityValidator = {
    filterInput: noFilter,
    validate: (value, context) => {
        var _a;
        const strValue = typeof value === 'number' ? value.toString() : value;
        const is1HNMR = (_a = context === null || context === void 0 ? void 0 : context.is1HNMR) !== null && _a !== void 0 ? _a : false;
        // Only validate for 1H NMR
        if (!is1HNMR) {
            return { isValid: true };
        }
        if (!strValue || strValue.trim() === '') {
            return { isValid: false, errorMessage: 'Multiplicity is required for 1H NMR' };
        }
        const multiplicityText = convertMultiplicityToText(strValue);
        try {
            NMRPeak.multipletnumbers(multiplicityText);
            return { isValid: true };
        }
        catch (error) {
            return { isValid: false, errorMessage: 'Invalid multiplicity' };
        }
    }
};
/**
 * J-value validator
 * @param context.multiplicity - The multiplicity text to determine required J count
 * @param context.jIndex - Index of this J-value (0-based)
 * @param context.allJValues - All J-values for this peak
 */
const jValueValidator = {
    filterInput: filterNumericInput,
    validate: (value, context) => {
        if (!(context === null || context === void 0 ? void 0 : context.multiplicity)) {
            return { isValid: true }; // No multiplicity, no validation
        }
        const multiplicityText = convertMultiplicityToText(context.multiplicity);
        const jCounts = NMRPeak.multipletnumbers(multiplicityText);
        if (jCounts === null) {
            return { isValid: true }; // Singlet/multiplet/broad - no J-values needed
        }
        const requiredJCount = jCounts.length;
        const isOptional = NMRPeak.isJValuesOptional(multiplicityText);
        const actualJCount = context.allJValues.filter(j => !isNaN(j) && j !== 0).length;
        if (isOptional) {
            // Optional: either all empty or all filled
            if (actualJCount > 0 && actualJCount < requiredJCount) {
                // Partial fill - check if this specific J-value is empty
                const numValue = typeof value === 'number' ? value : parseFloat(value);
                if (isNaN(numValue) || numValue === 0) {
                    return { isValid: false, errorMessage: 'All J-values must be filled' };
                }
            }
            return { isValid: true };
        }
        else {
            // Not optional: all must be filled
            if (context.jIndex < requiredJCount) {
                const numValue = typeof value === 'number' ? value : parseFloat(value);
                if (isNaN(numValue) || numValue === 0) {
                    return { isValid: false, errorMessage: 'J-value is required' };
                }
            }
            return { isValid: true };
        }
    }
};
/**
 * Integration validator
 * @param context.is1HNMR - Whether this is 1H NMR (integration required)
 */
const integrationValidator = {
    filterInput: filterNumericInput,
    validate: (value, context) => {
        var _a;
        const is1HNMR = (_a = context === null || context === void 0 ? void 0 : context.is1HNMR) !== null && _a !== void 0 ? _a : false;
        // Only validate for 1H NMR
        if (!is1HNMR) {
            return { isValid: true };
        }
        const numValue = typeof value === 'number' ? value : parseFloat(value);
        if (isNaN(numValue) || numValue === 0) {
            return { isValid: false, errorMessage: 'Integration is required for 1H NMR' };
        }
        return { isValid: true };
    }
};
/**
 * Assignment validator
 * No validation - optional field
 */
const assignmentValidator = {
    filterInput: noFilter, // HTML filtering is done separately in the UI
    validate: () => {
        return { isValid: true }; // Always valid - optional field
    }
};
/**
 * Get validator for a specific field type
 */
function getValidator(fieldType) {
    const validators = {
        'shift': shiftValidator,
        'multiplicity': multiplicityValidator,
        'jValue': jValueValidator,
        'integration': integrationValidator,
        'assignment': assignmentValidator
    };
    return validators[fieldType] || null;
}

// ========== STATE MANAGEMENT ==========
/**
 * Metadata State Management
 * Manages nuclei, solvent, frequency, precision, and sort order
 */
class MetadataState {
    constructor(initialData) {
        this.changeListeners = [];
        this.data = Object.assign({ nuclei: '<sup>1</sup>H', solvent: '', frequency: NaN, shiftPrecision: 3, jPrecision: 2, sortOrder: 'desc' }, initialData);
    }
    getData() {
        return Object.assign({}, this.data);
    }
    update(updates) {
        this.data = Object.assign(Object.assign({}, this.data), updates);
        this.notifyChange();
    }
    setNuclei(nuclei) {
        this.data.nuclei = nuclei;
        this.notifyChange();
    }
    setSolvent(solvent) {
        this.data.solvent = solvent;
        this.notifyChange();
    }
    setFrequency(frequency) {
        this.data.frequency = frequency;
        this.notifyChange();
    }
    setShiftPrecision(precision) {
        this.data.shiftPrecision = precision;
        this.notifyChange();
    }
    setJPrecision(precision) {
        this.data.jPrecision = precision;
        this.notifyChange();
    }
    setSortOrder(order) {
        this.data.sortOrder = order;
        this.notifyChange();
    }
    onChange(listener) {
        this.changeListeners.push(listener);
    }
    notifyChange() {
        this.changeListeners.forEach(listener => listener(this.getData()));
    }
}

/**
 * Table State Management
 * Manages NMR peak rows (shift, multiplicity, J-values, integration, assignment)
 */
class TableState {
    constructor() {
        this.rows = [];
        this.maxJColumns = 0;
        this.changeListeners = [];
        // Initialize with one empty row
        this.addRow();
    }
    getRows() {
        return this.rows.map(row => (Object.assign({}, row)));
    }
    getMaxJColumns() {
        return this.maxJColumns;
    }
    addRow(data) {
        const id = this.generateId();
        const newRow = Object.assign({ id, shift: '', multiplicity: '', jValues: [], integration: 0, assignment: '' }, data);
        this.rows.push(newRow);
        this.recalculateMaxJ();
        this.notifyChange();
        return id;
    }
    updateRow(id, updates) {
        const row = this.rows.find(r => r.id === id);
        if (row) {
            Object.assign(row, updates);
            this.recalculateMaxJ();
            this.notifyChange();
        }
    }
    removeRow(id) {
        this.rows = this.rows.filter(r => r.id !== id);
        // Ensure at least one row exists
        if (this.rows.length === 0) {
            this.addRow();
        }
        else {
            this.recalculateMaxJ();
            this.notifyChange();
        }
    }
    removeRows(ids) {
        this.rows = this.rows.filter(r => !ids.includes(r.id));
        // Ensure at least one row exists
        if (this.rows.length === 0) {
            this.addRow();
        }
        else {
            this.recalculateMaxJ();
            this.notifyChange();
        }
    }
    removeEmptyRows() {
        const emptyRowIds = this.rows
            .filter(row => {
            return row.shift.trim() === '' &&
                row.multiplicity.trim() === '' &&
                row.jValues.every(j => j === 0) &&
                row.integration === 0 &&
                row.assignment.trim() === '';
        })
            .map(row => row.id);
        if (emptyRowIds.length > 0) {
            this.removeRows(emptyRowIds);
        }
    }
    sortAllJValues() {
        this.rows.forEach(row => {
            if (row.jValues.length > 0) {
                row.jValues = [...row.jValues].sort((a, b) => b - a);
            }
        });
        this.notifyChange();
    }
    getRow(id) {
        const row = this.rows.find(r => r.id === id);
        return row ? Object.assign({}, row) : undefined;
    }
    setMaxJColumns(maxJ) {
        this.maxJColumns = maxJ;
        this.notifyChange();
    }
    recalculateMaxJ() {
        // This will be called by the UI layer after calculating required J columns
        // For now, we just store the value
    }
    onChange(listener) {
        this.changeListeners.push(listener);
    }
    notifyChange() {
        this.changeListeners.forEach(listener => listener(this.getRows(), this.maxJColumns));
    }
    generateId() {
        return `row-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    }
}

/**
 * Validation State Management
 * Tracks validation errors for metadata and table fields
 */
class ValidationState {
    constructor() {
        this.errors = new Map();
        this.changeListeners = [];
    }
    hasError(fieldId) {
        return this.errors.has(fieldId);
    }
    getError(fieldId) {
        return this.errors.get(fieldId);
    }
    getAllErrors() {
        return new Map(this.errors);
    }
    setError(fieldId, message) {
        this.errors.set(fieldId, message);
        this.notifyChange();
    }
    clearError(fieldId) {
        this.errors.delete(fieldId);
        this.notifyChange();
    }
    clearAllErrors() {
        this.errors.clear();
        this.notifyChange();
    }
    hasAnyErrors() {
        return this.errors.size > 0;
    }
    onChange(listener) {
        this.changeListeners.push(listener);
    }
    notifyChange() {
        this.changeListeners.forEach(listener => listener(this.getAllErrors()));
    }
}

/**
 * Application State Management
 * Central state container for the entire NMR Formatter application
 */
class AppState {
    constructor() {
        this.changeListeners = [];
        this.metadata = new MetadataState();
        this.table = new TableState();
        this.validation = new ValidationState();
        // Propagate child state changes to app-level listeners
        this.metadata.onChange(() => this.notifyChange());
        this.table.onChange(() => this.notifyChange());
        this.validation.onChange(() => this.notifyChange());
    }
    /**
     * Register a listener for any state change
     */
    onChange(listener) {
        this.changeListeners.push(listener);
    }
    /**
     * Clear all errors in validation state
     */
    clearAllErrors() {
        this.validation.clearAllErrors();
    }
    /**
     * Reset the entire application state
     */
    reset() {
        this.metadata = new MetadataState();
        this.table = new TableState();
        this.validation = new ValidationState();
        this.notifyChange();
    }
    notifyChange() {
        this.changeListeners.forEach(listener => listener());
    }
}

// ========== UI COMPONENTS ==========
/**
 * Metadata Form Component
 * Handles nuclei, solvent, frequency, precision, and sort order inputs
 */
class MetadataForm {
    constructor(metadataState, validationState, onNavigateNext, onSortOrderChange) {
        // AbortController for cleaning up event listeners
        this.abortController = new AbortController();
        this.metadataState = metadataState;
        this.validationState = validationState;
        this.onSortOrderChange = onSortOrderChange;
        this.elements = {
            nuclei: document.getElementById('nuclei'),
            solvent: document.getElementById('solvent'),
            frequency: document.getElementById('frequency'),
            shiftPrecision: document.getElementById('shift-precision'),
            jPrecision: document.getElementById('j-precision'),
            sortOrder: document.getElementById('sort-order')
        };
        this.dropdowns = {
            nuclei: document.getElementById('nuclei-dropdown'),
            solvent: document.getElementById('solvent-dropdown')
        };
        this.initializeValues();
        this.initializeEventListeners(onNavigateNext);
        this.initializeDropdowns();
    }
    initializeValues() {
        const data = this.metadataState.getData();
        // Add .input-richtext class for toolbar integration
        this.elements.nuclei.classList.add('input-richtext');
        this.elements.solvent.classList.add('input-richtext');
        this.elements.nuclei.innerHTML = data.nuclei;
        this.elements.solvent.innerHTML = data.solvent;
        this.elements.frequency.textContent = isNaN(data.frequency) ? '' : data.frequency.toString();
        this.elements.shiftPrecision.textContent = '';
        this.elements.jPrecision.textContent = '';
        // Set sort order icon (default: Descending = down arrow)
        this.updateSortOrderIcon(data.sortOrder);
    }
    initializeEventListeners(onNavigateNext) {
        // Nuclei input
        this.setupContentEditableField(this.elements.nuclei, (value) => {
            this.metadataState.setNuclei(value);
        }, onNavigateNext);
        // Solvent input
        this.setupContentEditableField(this.elements.solvent, (value) => {
            this.metadataState.setSolvent(value);
        }, onNavigateNext);
        // Number fields
        this.setupNumberField(this.elements.frequency, (value) => {
            this.metadataState.setFrequency(value);
        }, null, null, onNavigateNext);
        this.setupNumberField(this.elements.shiftPrecision, (value) => {
            this.metadataState.setShiftPrecision(value);
        }, 1, 10, onNavigateNext);
        this.setupNumberField(this.elements.jPrecision, (value) => {
            this.metadataState.setJPrecision(value);
        }, 1, 10, onNavigateNext);
        // Sort order - toggle button
        this.setupSortOrderToggle(onNavigateNext);
        // Validation error display
        this.validationState.onChange((errors) => {
            Object.values(this.elements).forEach(el => {
                if (el instanceof HTMLElement) {
                    const fieldId = el.id;
                    if (errors.has(fieldId)) {
                        el.classList.add('error');
                    }
                    else {
                        el.classList.remove('error');
                    }
                }
            });
        });
    }
    setupContentEditableField(element, onChange, onNavigateNext) {
        // Paste filtering (only allow B, I, SUB, SUP tags)
        element.addEventListener('paste', (e) => {
            var _a, _b;
            e.preventDefault();
            const text = ((_a = e.clipboardData) === null || _a === void 0 ? void 0 : _a.getData('text/html')) || ((_b = e.clipboardData) === null || _b === void 0 ? void 0 : _b.getData('text/plain')) || '';
            const temp = document.createElement('div');
            temp.innerHTML = text;
            const filtered = this.filterHTMLTags(temp, ['B', 'I', 'SUB', 'SUP']);
            document.execCommand('insertHTML', false, filtered);
        }, { signal: this.abortController.signal });
        // Input handling
        element.addEventListener('input', () => {
            onChange(element.innerHTML);
            this.validationState.clearError(element.id);
        }, { signal: this.abortController.signal });
        // Enter, Tab, and Arrow key navigation
        element.addEventListener('keydown', (e) => {
            // Check if dropdown is active and has a highlighted item
            const fieldId = element.id;
            const dropdown = fieldId === 'nuclei' ? this.dropdowns.nuclei :
                fieldId === 'solvent' ? this.dropdowns.solvent : null;
            if (e.key === 'Enter') {
                // If dropdown is active and has a highlighted item, let it handle Enter
                if (dropdown && dropdown.classList.contains('active')) {
                    const highlightedItem = dropdown.querySelector('.dropdown-item.highlighted');
                    if (highlightedItem) {
                        // Don't navigate, let dropdown handler select the item
                        return;
                    }
                }
                // Otherwise, navigate to next field within the same group
                e.preventDefault();
                this.navigateWithinGroup(element, e.shiftKey);
                return;
            }
            if (e.key === 'Tab') {
                e.preventDefault();
                this.navigateWithinGroup(element, e.shiftKey);
                return;
            }
            // Smart left/right arrow navigation at boundaries
            if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
                const selection = window.getSelection();
                if (!selection || selection.rangeCount === 0)
                    return;
                const range = selection.getRangeAt(0);
                const text = element.textContent || '';
                // Check if there's a selection
                const hasSelection = !range.collapsed;
                if (!hasSelection) {
                    const cursorPosition = this.getCursorPosition(element);
                    if (e.key === 'ArrowRight' && cursorPosition >= text.length) {
                        // At right boundary, move to next field within group
                        e.preventDefault();
                        const fieldGroup = this.getFieldGroup(element);
                        const fieldIndex = fieldGroup.indexOf(element);
                        if (fieldIndex < fieldGroup.length - 1) {
                            const nextField = fieldGroup[fieldIndex + 1];
                            nextField.focus();
                            this.moveCursorToStart(nextField);
                        }
                        return;
                    }
                    else if (e.key === 'ArrowLeft' && cursorPosition === 0) {
                        // At left boundary, move to previous field within group
                        e.preventDefault();
                        const fieldGroup = this.getFieldGroup(element);
                        const fieldIndex = fieldGroup.indexOf(element);
                        if (fieldIndex > 0) {
                            const prevField = fieldGroup[fieldIndex - 1];
                            prevField.focus();
                            this.moveCursorToEnd(prevField);
                        }
                        return;
                    }
                }
            }
            // Keyboard shortcuts (Ctrl+B, Ctrl+I)
            if (e.ctrlKey || e.metaKey) {
                if (e.key === 'b' || e.key === 'B') {
                    e.preventDefault();
                    document.execCommand('bold');
                }
                else if (e.key === 'i' || e.key === 'I') {
                    e.preventDefault();
                    document.execCommand('italic');
                }
            }
        }, { signal: this.abortController.signal });
        // Ensure placeholder shows when field is empty on blur
        element.addEventListener('blur', () => {
            const cleaned = this.cleanupEmptyTags(element.innerHTML);
            if (cleaned === '' || cleaned === '<br>') {
                element.innerHTML = '';
            }
            else if (cleaned !== element.innerHTML) {
                element.innerHTML = cleaned;
            }
        }, { signal: this.abortController.signal });
    }
    setupNumberField(element, onChange, min, max, onNavigateNext) {
        // Enter, Tab, and Arrow key navigation
        element.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                // Prevent default behavior and stop propagation to avoid input event
                e.stopPropagation();
                this.navigateWithinGroup(element, e.shiftKey);
                return;
            }
            if (e.key === 'Tab') {
                e.preventDefault();
                this.navigateWithinGroup(element, e.shiftKey);
                return;
            }
            // Smart left/right arrow navigation at boundaries
            if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
                const selection = window.getSelection();
                if (!selection || selection.rangeCount === 0)
                    return;
                const range = selection.getRangeAt(0);
                const text = element.textContent || '';
                // Check if there's a selection
                const hasSelection = !range.collapsed;
                if (!hasSelection) {
                    const cursorPosition = this.getCursorPosition(element);
                    if (e.key === 'ArrowRight' && cursorPosition >= text.length) {
                        // At right boundary, move to next field within group
                        e.preventDefault();
                        const fieldGroup = this.getFieldGroup(element);
                        const fieldIndex = fieldGroup.indexOf(element);
                        if (fieldIndex < fieldGroup.length - 1) {
                            const nextField = fieldGroup[fieldIndex + 1];
                            nextField.focus();
                            this.moveCursorToStart(nextField);
                        }
                        return;
                    }
                    else if (e.key === 'ArrowLeft' && cursorPosition === 0) {
                        // At left boundary, move to previous field within group
                        e.preventDefault();
                        const fieldGroup = this.getFieldGroup(element);
                        const fieldIndex = fieldGroup.indexOf(element);
                        if (fieldIndex > 0) {
                            const prevField = fieldGroup[fieldIndex - 1];
                            prevField.focus();
                            this.moveCursorToEnd(prevField);
                        }
                        return;
                    }
                }
            }
        }, { signal: this.abortController.signal });
        // Input validation
        element.addEventListener('input', () => {
            const text = element.textContent || '';
            const cleanText = text.replace(/[^0-9]/g, '');
            if (text !== cleanText) {
                element.textContent = cleanText;
                this.moveCursorToEnd(element);
            }
            if (cleanText !== '') {
                const num = parseInt(cleanText);
                onChange(num);
                if ((min !== null && num < min) || (max !== null && num > max)) {
                    element.classList.add('error');
                }
                else {
                    element.classList.remove('error');
                }
            }
            else {
                element.classList.remove('error');
            }
        }, { signal: this.abortController.signal });
        // Paste filtering
        element.addEventListener('paste', (e) => {
            var _a;
            e.preventDefault();
            const text = ((_a = e.clipboardData) === null || _a === void 0 ? void 0 : _a.getData('text/plain')) || '';
            const cleanText = text.replace(/[^0-9]/g, '');
            document.execCommand('insertText', false, cleanText);
        }, { signal: this.abortController.signal });
        // Clear error on focus
        element.addEventListener('focus', () => {
            this.validationState.clearError(element.id);
        }, { signal: this.abortController.signal });
        // Ensure placeholder shows when field is empty on blur
        element.addEventListener('blur', () => {
            const text = element.textContent || '';
            if (text.trim() === '') {
                element.textContent = '';
            }
        }, { signal: this.abortController.signal });
    }
    initializeDropdowns() {
        this.setupDropdown('nuclei', NUCLEI_PRESETS);
        this.setupDropdown('solvent', SOLVENT_PRESETS);
    }
    setupDropdown(field, presets) {
        const input = this.elements[field];
        const dropdown = this.dropdowns[field];
        if (!input || !dropdown)
            return;
        // Prevent dropdown from receiving focus
        dropdown.setAttribute('tabindex', '-1');
        // Populate dropdown
        dropdown.innerHTML = '';
        presets.forEach(preset => {
            const item = document.createElement('div');
            item.className = 'dropdown-item';
            item.setAttribute('data-value', preset.displayHTML);
            item.innerHTML = preset.displayHTML;
            dropdown.appendChild(item);
        });
        // Track selected index for keyboard navigation
        let selectedIndex = -1;
        // Show/hide dropdown
        input.addEventListener('focus', () => {
            dropdown.classList.add('active');
            selectedIndex = -1; // Reset selection on focus
        }, { signal: this.abortController.signal });
        input.addEventListener('blur', () => {
            setTimeout(() => {
                dropdown.classList.remove('active');
                // Clear highlight
                dropdown.querySelectorAll('.dropdown-item').forEach(item => {
                    item.classList.remove('highlighted');
                });
            }, 200);
        }, { signal: this.abortController.signal });
        // Keyboard navigation for dropdown
        input.addEventListener('keydown', (e) => {
            if (!dropdown.classList.contains('active'))
                return;
            const items = Array.from(dropdown.querySelectorAll('.dropdown-item'));
            if (items.length === 0)
                return;
            if (e.key === 'ArrowDown') {
                e.preventDefault();
                selectedIndex = Math.min(selectedIndex + 1, items.length - 1);
                this.highlightDropdownItem(items, selectedIndex);
            }
            else if (e.key === 'ArrowUp') {
                e.preventDefault();
                selectedIndex = Math.max(selectedIndex - 1, -1);
                this.highlightDropdownItem(items, selectedIndex);
            }
            else if (e.key === 'Enter' && selectedIndex >= 0) {
                e.preventDefault();
                const value = items[selectedIndex].getAttribute('data-value') || '';
                input.innerHTML = value;
                this.handleDropdownSelection(field, value);
                dropdown.classList.remove('active');
                // Clear highlight
                this.highlightDropdownItem(items, -1);
                selectedIndex = -1;
            }
        }, { signal: this.abortController.signal });
        // Handle selection
        dropdown.querySelectorAll('.dropdown-item').forEach(item => {
            item.addEventListener('mousedown', (e) => {
                e.preventDefault();
                const value = item.getAttribute('data-value') || '';
                input.innerHTML = value;
                this.handleDropdownSelection(field, value);
                dropdown.classList.remove('active');
            }, { signal: this.abortController.signal });
        });
    }
    /**
     * Highlight the selected dropdown item
     */
    highlightDropdownItem(items, index) {
        items.forEach((item, i) => {
            if (i === index) {
                item.classList.add('highlighted');
                item.scrollIntoView({ block: 'nearest' });
            }
            else {
                item.classList.remove('highlighted');
            }
        });
    }
    /**
     * Handle dropdown selection for different fields
     */
    handleDropdownSelection(field, value) {
        if (field === 'nuclei') {
            this.metadataState.setNuclei(value);
        }
        else if (field === 'solvent') {
            this.metadataState.setSolvent(value);
        }
    }
    /**
     * Get cursor position in contenteditable element
     */
    getCursorPosition(element) {
        const selection = window.getSelection();
        if (!selection || selection.rangeCount === 0)
            return 0;
        const range = selection.getRangeAt(0);
        const preCaretRange = range.cloneRange();
        preCaretRange.selectNodeContents(element);
        preCaretRange.setEnd(range.endContainer, range.endOffset);
        return preCaretRange.toString().length;
    }
    /**
     * Move cursor to start of element
     */
    moveCursorToStart(element) {
        const range = document.createRange();
        const sel = window.getSelection();
        if (element.childNodes.length > 0) {
            range.setStart(element.childNodes[0], 0);
            range.collapse(true);
            sel === null || sel === void 0 ? void 0 : sel.removeAllRanges();
            sel === null || sel === void 0 ? void 0 : sel.addRange(range);
        }
    }
    /**
     * Setup sort order toggle button
     */
    setupSortOrderToggle(onNavigateNext) {
        const button = this.elements.sortOrder;
        // Click handler - toggle between asc and desc
        button.addEventListener('click', (e) => {
            var _a;
            e.preventDefault();
            const currentOrder = this.metadataState.getData().sortOrder;
            const newOrder = currentOrder === 'desc' ? 'asc' : 'desc';
            this.metadataState.setSortOrder(newOrder);
            this.updateSortOrderIcon(newOrder);
            // Trigger formatted text regeneration
            (_a = this.onSortOrderChange) === null || _a === void 0 ? void 0 : _a.call(this);
        }, { signal: this.abortController.signal });
        // Keyboard navigation
        button.addEventListener('keydown', (e) => {
            var _a;
            if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                const currentOrder = this.metadataState.getData().sortOrder;
                const newOrder = currentOrder === 'desc' ? 'asc' : 'desc';
                this.metadataState.setSortOrder(newOrder);
                this.updateSortOrderIcon(newOrder);
                // Trigger formatted text regeneration
                (_a = this.onSortOrderChange) === null || _a === void 0 ? void 0 : _a.call(this);
                return;
            }
            if (e.key === 'Tab') {
                e.preventDefault();
                this.navigateWithinGroup(button, e.shiftKey);
                return;
            }
            // Arrow key navigation within field group
            if (e.key === 'ArrowLeft') {
                e.preventDefault();
                const fieldGroup = this.getFieldGroup(button);
                const fieldIndex = fieldGroup.indexOf(button);
                if (fieldIndex > 0) {
                    const prevField = fieldGroup[fieldIndex - 1];
                    prevField.focus();
                    this.moveCursorToEnd(prevField);
                }
                return;
            }
            if (e.key === 'ArrowRight') {
                e.preventDefault();
                const fieldGroup = this.getFieldGroup(button);
                const fieldIndex = fieldGroup.indexOf(button);
                if (fieldIndex < fieldGroup.length - 1) {
                    const nextField = fieldGroup[fieldIndex + 1];
                    nextField.focus();
                    this.moveCursorToStart(nextField);
                }
                return;
            }
        }, { signal: this.abortController.signal });
    }
    /**
     * Update sort order icon based on current state
     */
    updateSortOrderIcon(sortOrder) {
        const button = this.elements.sortOrder;
        const icon = button.querySelector('i');
        if (icon) {
            if (sortOrder === 'desc') {
                // Descending = down arrow
                icon.className = 'fi fi-rr-down';
                button.setAttribute('title', 'Sort: Descending (High → Low)');
            }
            else {
                // Ascending = up arrow
                icon.className = 'fi fi-rr-up';
                button.setAttribute('title', 'Sort: Ascending (Low → High)');
            }
        }
    }
    filterHTMLTags(element, allowedTags) {
        let result = '';
        element.childNodes.forEach(node => {
            if (node.nodeType === Node.TEXT_NODE) {
                result += node.textContent;
            }
            else if (node.nodeType === Node.ELEMENT_NODE) {
                const tagName = node.tagName.toUpperCase();
                if (allowedTags.includes(tagName)) {
                    result += `<${tagName.toLowerCase()}>${this.filterHTMLTags(node, allowedTags)}</${tagName.toLowerCase()}>`;
                }
                else {
                    result += this.filterHTMLTags(node, allowedTags);
                }
            }
        });
        return result;
    }
    moveCursorToEnd(element) {
        var _a;
        const range = document.createRange();
        const sel = window.getSelection();
        if (element.childNodes.length > 0) {
            // Find the last node (could be text or element)
            const lastNode = element.childNodes[element.childNodes.length - 1];
            if (lastNode.nodeType === Node.TEXT_NODE) {
                // Text node: set cursor at end
                const length = ((_a = lastNode.textContent) === null || _a === void 0 ? void 0 : _a.length) || 0;
                range.setStart(lastNode, length);
            }
            else if (lastNode.nodeType === Node.ELEMENT_NODE) {
                // Element node: set cursor after it
                range.setStartAfter(lastNode);
            }
            else {
                // Fallback: set after last node
                range.setStartAfter(lastNode);
            }
            range.collapse(true);
            sel === null || sel === void 0 ? void 0 : sel.removeAllRanges();
            sel === null || sel === void 0 ? void 0 : sel.addRange(range);
        }
    }
    /**
     * Remove empty HTML tags (tags with no text content)
     * @param html The HTML string to clean
     * @returns Cleaned HTML string
     */
    cleanupEmptyTags(html) {
        const temp = document.createElement('div');
        temp.innerHTML = html.trim();
        // Recursively remove empty elements
        const removeEmptyElements = (element) => {
            const children = Array.from(element.children);
            children.forEach(child => {
                var _a;
                removeEmptyElements(child);
                // Remove if element has no text content and no non-empty children
                const textContent = ((_a = child.textContent) === null || _a === void 0 ? void 0 : _a.trim()) || '';
                if (textContent === '' && child.children.length === 0) {
                    child.remove();
                }
            });
        };
        removeEmptyElements(temp);
        return temp.innerHTML;
    }
    getFieldOrder() {
        // Legacy method - returns all fields
        return [
            this.elements.nuclei,
            this.elements.solvent,
            this.elements.frequency,
            this.elements.shiftPrecision,
            this.elements.jPrecision,
            this.elements.sortOrder
        ];
    }
    /**
     * Get metadata fields order (group 1: nuclei → solvent → frequency)
     */
    getMetadataFieldOrder() {
        return [
            this.elements.nuclei,
            this.elements.solvent,
            this.elements.frequency
        ];
    }
    /**
     * Get settings fields order (group 2: shift-precision → j-precision → sort-order)
     */
    getSettingsFieldOrder() {
        return [
            this.elements.shiftPrecision,
            this.elements.jPrecision,
            this.elements.sortOrder
        ];
    }
    /**
     * Get the appropriate field group for the given element
     */
    getFieldGroup(element) {
        const metadataFields = this.getMetadataFieldOrder();
        const settingsFields = this.getSettingsFieldOrder();
        if (metadataFields.includes(element)) {
            return metadataFields;
        }
        else if (settingsFields.includes(element)) {
            return settingsFields;
        }
        return [];
    }
    /**
     * Navigate to next/previous field within the same group
     */
    /**
     * Navigate to next/previous field within the same group
     */
    navigateWithinGroup(element, reverse) {
        const fieldGroup = this.getFieldGroup(element);
        if (fieldGroup.length === 0)
            return;
        const currentIndex = fieldGroup.indexOf(element);
        if (currentIndex === -1)
            return;
        let targetIndex;
        if (reverse) {
            targetIndex = currentIndex - 1;
            // Don't wrap - stay at first field
            if (targetIndex < 0)
                return;
        }
        else {
            targetIndex = currentIndex + 1;
            // Don't wrap - stay at last field
            if (targetIndex >= fieldGroup.length)
                return;
        }
        const targetField = fieldGroup[targetIndex];
        targetField.focus();
        // Select all text in the target field
        this.selectAllText(targetField);
    }
    /**
     * Select all text in a contenteditable element
     */
    selectAllText(element) {
        const range = document.createRange();
        const sel = window.getSelection();
        range.selectNodeContents(element);
        sel === null || sel === void 0 ? void 0 : sel.removeAllRanges();
        sel === null || sel === void 0 ? void 0 : sel.addRange(range);
    }
    /**
     * Clean up event listeners and resources
     * Should be called when the component is destroyed
     */
    /**
     * Update form fields from current metadata state
     * Public method to refresh UI when state changes externally
     */
    updateFromState() {
        this.initializeValues();
    }
    destroy() {
        // Abort all event listeners attached with AbortController
        this.abortController.abort();
        // Create new AbortController for potential reuse
        this.abortController = new AbortController();
    }
}

/**
 * NMR Table Component
 * Manages the table UI for NMR peak data
 */
class NMRTable {
    constructor(tableState, validationState, onMultiplicityChange, onNavigateToMetadata) {
        this.maxJColumns = 0;
        // Row ID to TR element mapping
        this.rowElements = new Map();
        // AbortController for cleaning up event listeners
        this.abortController = new AbortController();
        this.tableState = tableState;
        this.validationState = validationState;
        this.tableBody = document.getElementById('nmr-table-body');
        this.tableElement = document.getElementById('nmr-table');
        this.keyboardNav = new KeyboardNav();
        this.initializeEventListeners(onMultiplicityChange, onNavigateToMetadata);
        this.renderTable();
        // Listen to state changes
        this.tableState.onChange((rows, maxJ) => {
            // Only re-render if rows were added/removed
            // For updates to existing rows, the DOM is already updated via event handlers
            const currentRowCount = this.rowElements.size;
            const newRowCount = rows.length;
            if (currentRowCount !== newRowCount) {
                this.maxJColumns = maxJ;
                this.renderTable();
            }
        });
        // Listen to validation state changes
        this.validationState.onChange((errors) => {
            this.rowElements.forEach((tr, rowId) => {
                // Shift input
                const shiftInput = tr.querySelector('.shift-input');
                if (shiftInput) {
                    if (errors.has(`shift-${rowId}`)) {
                        shiftInput.classList.add('error');
                    }
                    else {
                        shiftInput.classList.remove('error');
                    }
                }
                // Multiplicity input
                const multInput = tr.querySelector('.mult-input');
                if (multInput) {
                    if (errors.has(`mult-${rowId}`)) {
                        multInput.classList.add('error');
                    }
                    else {
                        multInput.classList.remove('error');
                    }
                }
                // Integration input
                const intInput = tr.querySelector('.int-input');
                if (intInput) {
                    if (errors.has(`int-${rowId}`)) {
                        intInput.classList.add('error');
                    }
                    else {
                        intInput.classList.remove('error');
                    }
                }
                // J-value inputs
                const jInputs = tr.querySelectorAll('.j-input');
                jInputs.forEach((jInput, index) => {
                    if (errors.has(`j${index}-${rowId}`)) {
                        jInput.classList.add('error');
                    }
                    else {
                        jInput.classList.remove('error');
                    }
                });
                // Assignment input
                const assignmentInput = tr.querySelector('.assignment-input');
                if (assignmentInput) {
                    if (errors.has(`assignment-${rowId}`)) {
                        assignmentInput.classList.add('error');
                    }
                    else {
                        assignmentInput.classList.remove('error');
                    }
                }
            });
        });
    }
    /**
     * Get the column type from a cell element
     * @param cell - The cell element (td or the input element inside it)
     * @returns Column type string (e.g., 'shift', 'multiplicity', 'j-0', 'integration', 'assignment') or null
     */
    getCellColumnType(cell) {
        // If cell is an input element, get its parent td
        const tdElement = cell.tagName === 'TD' ? cell : cell.closest('td');
        if (!tdElement)
            return null;
        // Check for shift input
        if (tdElement.querySelector('.shift-input'))
            return 'shift';
        // Check for multiplicity input
        if (tdElement.querySelector('.mult-input'))
            return 'multiplicity';
        // Check for J input
        const jInput = tdElement.querySelector('.j-input');
        if (jInput) {
            const jIndex = jInput.getAttribute('data-j-index');
            return jIndex !== null ? `j-${jIndex}` : null;
        }
        // Check for integration input
        if (tdElement.querySelector('.int-input'))
            return 'integration';
        // Check for assignment input
        if (tdElement.querySelector('.assignment-input'))
            return 'assignment';
        return null;
    }
    /**
     * Handle TSV paste operation
     * @param startElement - The input element where paste was initiated
     * @param startRow - The row where paste was initiated
     * @param tsvText - The TSV text to paste
     */
    async handleTSVPaste(startElement, startRow, tsvText) {
        console.log('[TSV Paste] Starting with text:', tsvText);
        // Parse TSV data
        const rows = tsvText.split(/\r?\n/).map(line => line.split('\t'));
        console.log('[TSV Paste] Parsed into rows:', rows.length, rows);
        // Filter out empty rows
        const validRows = rows.filter(row => row.length > 0 && row.some(cell => cell.trim() !== ''));
        console.log('[TSV Paste] Valid rows:', validRows.length, validRows);
        // Get the starting cell and determine which column we're starting from
        const startCell = startElement.closest('td');
        if (!startCell) {
            console.log('[TSV Paste] No start cell found');
            return;
        }
        // Get the column index of the start cell
        const startCells = Array.from(startRow.querySelectorAll('td'));
        const startColumnIndex = startCells.indexOf(startCell);
        console.log('[TSV Paste] Start column index in row:', startColumnIndex);
        // Get all table rows
        let currentRow = startRow;
        // Process each TSV row
        for (let rowIdx = 0; rowIdx < validRows.length; rowIdx++) {
            const tsvRow = validRows[rowIdx];
            console.log(`[TSV Paste] Processing row ${rowIdx}/${validRows.length}:`, tsvRow);
            // If we need more rows, add them
            if (!currentRow) {
                console.log('[TSV Paste] Current row is null, adding new row');
                const newId = this.tableState.addRow();
                // Wait for the row to be rendered
                await new Promise(resolve => {
                    requestAnimationFrame(() => {
                        const newRowElement = this.rowElements.get(newId);
                        if (newRowElement) {
                            console.log('[TSV Paste] New row rendered, applying data');
                            // Find the corresponding cell in the new row at the same column index
                            const newRowCells = Array.from(newRowElement.querySelectorAll('td'));
                            const newStartCell = newRowCells[startColumnIndex];
                            if (newStartCell) {
                                this.applyTSVRowDataSequentially(newRowElement, newStartCell, tsvRow).then(resolve);
                            }
                            else {
                                console.log('[TSV Paste] Could not find start cell in new row');
                                resolve();
                            }
                        }
                        else {
                            console.log('[TSV Paste] New row not found in rowElements');
                            resolve();
                        }
                    });
                });
            }
            else {
                console.log('[TSV Paste] Applying data to existing row');
                // For existing rows, find the start cell at the same column index
                const rowCells = Array.from(currentRow.querySelectorAll('td'));
                const rowStartCell = rowCells[startColumnIndex];
                if (rowStartCell) {
                    await this.applyTSVRowDataSequentially(currentRow, rowStartCell, tsvRow);
                }
                // Move to next row
                const nextRow = currentRow.nextElementSibling;
                console.log('[TSV Paste] Looking for next row:', nextRow === null || nextRow === void 0 ? void 0 : nextRow.tagName, nextRow === null || nextRow === void 0 ? void 0 : nextRow.classList.toString());
                if (nextRow && !nextRow.classList.contains('add-row-footer')) {
                    currentRow = nextRow;
                    console.log('[TSV Paste] Moving to next existing row');
                }
                else {
                    currentRow = null;
                    console.log('[TSV Paste] No more existing rows, will create new ones');
                }
            }
        }
        console.log('[TSV Paste] Completed all rows');
    }
    /**
     * Apply TSV row data to a table row
     * @param row - The table row element
     * @param columnTypes - Array of column type strings
     * @param startColIndex - Starting column index
     * @param data - Array of cell values
     */
    async applyTSVRowDataSequentially(row, startCell, data) {
        // Build column type map dynamically as we go
        const startCellElement = startCell.closest('td');
        if (!startCellElement)
            return;
        // Get all cells
        let allCells = Array.from(row.querySelectorAll('td'));
        let currentCellIndex = allCells.indexOf(startCellElement);
        if (currentCellIndex === -1)
            return;
        // Apply each data value sequentially
        for (let dataIdx = 0; dataIdx < data.length; dataIdx++) {
            const value = data[dataIdx];
            // Find next visible cell from current position
            let targetCell = null;
            for (let i = currentCellIndex; i < allCells.length; i++) {
                const cell = allCells[i];
                const computedStyle = window.getComputedStyle(cell);
                if (computedStyle.display !== 'none') {
                    targetCell = cell;
                    currentCellIndex = i + 1; // Move to next for next iteration
                    break;
                }
            }
            if (!targetCell)
                break; // No more visible cells
            // Get the input element in this cell
            const inputElement = targetCell.querySelector('input, [contenteditable="true"]');
            if (!inputElement)
                continue;
            // Determine column type
            const colType = this.getCellColumnType(targetCell);
            // Set value
            if (colType === 'assignment') {
                inputElement.innerHTML = value;
            }
            else {
                inputElement.value = value;
            }
            // Dispatch input event to trigger validation and state update
            inputElement.dispatchEvent(new Event('input', { bubbles: true }));
            // If this is multiplicity, wait for J columns to update
            if (colType === 'multiplicity') {
                // Wait for DOM updates to complete
                await new Promise(resolve => {
                    requestAnimationFrame(() => {
                        requestAnimationFrame(() => {
                            resolve();
                        });
                    });
                });
                // Rebuild the cell list with updated visibility
                allCells = Array.from(row.querySelectorAll('td'));
                // Find current position in updated list
                currentCellIndex = allCells.indexOf(targetCell) + 1;
            }
        }
    }
    initializeEventListeners(onMultiplicityChange, onNavigateToMetadata) {
        // Add row footer cell
        this.renderAddRowFooter();
    }
    renderAddRowFooter() {
        // Remove existing add-row if present
        const existingAddRow = this.tableBody.querySelector('.add-row-footer');
        if (existingAddRow) {
            existingAddRow.remove();
        }
        const addRow = document.createElement('tr');
        addRow.className = 'add-row-footer';
        // Empty delete cell
        const deleteCell = document.createElement('td');
        deleteCell.className = 'delete-cell';
        addRow.appendChild(deleteCell);
        // Calculate remaining columns (shift + mult + J columns + integration + assignment)
        const remainingColumns = 4 + this.maxJColumns;
        const addCell = document.createElement('td');
        addCell.className = 'add-row-cell';
        addCell.colSpan = remainingColumns;
        addCell.innerHTML = '<button class="add-row-btn" title="Add new row">+</button>';
        const addButton = addCell.querySelector('.add-row-btn');
        addButton.tabIndex = -1; // Exclude from tab order
        addButton.addEventListener('click', () => {
            const newId = this.tableState.addRow();
            requestAnimationFrame(() => {
                const newRow = this.rowElements.get(newId);
                if (newRow) {
                    const firstInput = newRow.querySelector('.shift-input');
                    firstInput === null || firstInput === void 0 ? void 0 : firstInput.focus();
                }
            });
        }, { signal: this.abortController.signal });
        addRow.appendChild(addCell);
        this.tableBody.appendChild(addRow);
    }
    renderTable() {
        const rows = this.tableState.getRows();
        // Clear existing rows
        this.tableBody.innerHTML = '';
        this.rowElements.clear();
        // Render each row
        rows.forEach(rowData => {
            const tr = this.createTableRow(rowData);
            this.rowElements.set(rowData.id, tr);
            this.tableBody.appendChild(tr);
        });
        // Update J column visibility to preserve table state
        this.updateJColumnVisibility();
        // Re-render footer to update column span
        this.renderAddRowFooter();
    }
    createTableRow(rowData) {
        const row = document.createElement('tr');
        row.setAttribute('data-row-id', rowData.id);
        // Delete button cell
        const deleteCell = document.createElement('td');
        deleteCell.className = 'delete-cell';
        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'delete-row-btn';
        deleteBtn.textContent = '×';
        deleteBtn.title = 'Delete this row';
        deleteBtn.tabIndex = -1;
        deleteCell.appendChild(deleteBtn);
        this.setupDeleteButton(deleteBtn, rowData.id);
        row.appendChild(deleteCell);
        // Chemical shift cell
        const shiftCell = document.createElement('td');
        const shiftInput = document.createElement('input');
        shiftInput.type = 'text';
        shiftInput.className = 'shift-input';
        shiftInput.placeholder = '0.00 or 7.53–7.50';
        shiftInput.value = rowData.shift;
        shiftCell.appendChild(shiftInput);
        this.setupShiftInput(shiftInput, rowData.id, row);
        row.appendChild(shiftCell);
        // Multiplicity cell
        const multCell = document.createElement('td');
        const multInput = document.createElement('input');
        multInput.type = 'text';
        multInput.className = 'mult-input';
        multInput.placeholder = 's, d, t...';
        multInput.value = rowData.multiplicity;
        multCell.appendChild(multInput);
        this.setupMultiplicityInput(multInput, rowData.id, row);
        row.appendChild(multCell);
        // J-value cells (10 max, dynamically shown/hidden)
        const MAX_J_CELLS = 10;
        for (let i = 0; i < MAX_J_CELLS; i++) {
            const jCell = document.createElement('td');
            jCell.className = 'j-input-cell';
            const jInput = document.createElement('input');
            jInput.type = 'text';
            jInput.className = 'j-input';
            jInput.setAttribute('data-j-index', i.toString());
            jInput.setAttribute('inputmode', 'decimal');
            jInput.placeholder = '0.0';
            if (i < rowData.jValues.length) {
                jInput.value = rowData.jValues[i].toString();
            }
            jCell.appendChild(jInput);
            this.setupJInput(jInput, rowData.id, i, row);
            // Initially hide all J cells
            jCell.style.display = 'none';
            row.appendChild(jCell);
        }
        // Integration cell
        const intCell = document.createElement('td');
        intCell.className = 'int-cell';
        const intInput = document.createElement('input');
        intInput.type = 'text';
        intInput.className = 'int-input';
        intInput.setAttribute('inputmode', 'decimal');
        intInput.placeholder = '1';
        if (rowData.integration) {
            intInput.value = rowData.integration.toString();
        }
        intCell.appendChild(intInput);
        this.setupIntegrationInput(intInput, rowData.id, row);
        row.appendChild(intCell);
        // Assignment cell
        const assignmentCell = document.createElement('td');
        assignmentCell.className = 'assignment-cell';
        const assignmentInput = document.createElement('div');
        assignmentInput.className = 'assignment-input input-richtext';
        assignmentInput.setAttribute('contenteditable', 'true');
        assignmentInput.setAttribute('data-placeholder', 'e.g., H-8');
        assignmentInput.innerHTML = rowData.assignment;
        assignmentCell.appendChild(assignmentInput);
        this.setupAssignmentInput(assignmentInput, rowData.id, row);
        row.appendChild(assignmentCell);
        return row;
    }
    setupShiftInput(input, rowId, row) {
        // Handle paste event
        input.addEventListener('paste', (e) => {
            const clipboardData = e.clipboardData;
            const text = (clipboardData === null || clipboardData === void 0 ? void 0 : clipboardData.getData('text/plain')) || '';
            if (isTSVData(text)) {
                e.preventDefault();
                this.handleTSVPaste(input, row, text);
            }
            // Otherwise, allow default paste behavior
        }, { signal: this.abortController.signal });
        input.addEventListener('input', () => {
            // Filter to allow numbers, decimal points, and range indicators (-–)
            const filtered = filterChemicalShiftInput(input.value);
            if (filtered !== input.value) {
                input.value = filtered;
            }
            this.tableState.updateRow(rowId, { shift: filtered });
            // Clear error on input (real-time clearing, no new errors shown)
            this.validationState.clearError(`shift-${rowId}`);
        }, { signal: this.abortController.signal });
        input.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                this.focusNextTableCell(input, row, e.shiftKey);
            }
            else if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                // Check if ArrowDown at last row
                if (e.key === 'ArrowDown') {
                    const isLastRow = !row.nextElementSibling || row.nextElementSibling.classList.contains('add-row-footer');
                    if (isLastRow) {
                        e.preventDefault();
                        const newId = this.tableState.addRow();
                        requestAnimationFrame(() => {
                            const newRow = this.rowElements.get(newId);
                            if (newRow) {
                                const targetInput = newRow.querySelector('.shift-input');
                                targetInput === null || targetInput === void 0 ? void 0 : targetInput.focus();
                            }
                        });
                        return;
                    }
                }
                this.keyboardNav.handleCellNavigation(e, input, row, (direction) => {
                    this.keyboardNav.navigateToCell(row, input, direction);
                });
            }
        }, { signal: this.abortController.signal });
    }
    setupMultiplicityInput(input, rowId, row) {
        // Handle paste event
        input.addEventListener('paste', (e) => {
            const clipboardData = e.clipboardData;
            const text = (clipboardData === null || clipboardData === void 0 ? void 0 : clipboardData.getData('text/plain')) || '';
            if (isTSVData(text)) {
                e.preventDefault();
                this.handleTSVPaste(input, row, text);
            }
            // Otherwise, allow default paste behavior
        }, { signal: this.abortController.signal });
        input.addEventListener('input', () => {
            this.tableState.updateRow(rowId, { multiplicity: input.value });
            // Clear error on input (real-time clearing, no new errors shown)
            this.validationState.clearError(`mult-${rowId}`);
            // Recalculate J columns when multiplicity changes
            this.updateJColumnVisibility();
        }, { signal: this.abortController.signal });
        input.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                this.focusNextTableCell(input, row, e.shiftKey);
            }
            else if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                // Check if ArrowDown at last row
                if (e.key === 'ArrowDown') {
                    const isLastRow = !row.nextElementSibling || row.nextElementSibling.classList.contains('add-row-footer');
                    if (isLastRow) {
                        e.preventDefault();
                        const newId = this.tableState.addRow();
                        requestAnimationFrame(() => {
                            const newRow = this.rowElements.get(newId);
                            if (newRow) {
                                const targetInput = newRow.querySelector('.mult-input');
                                targetInput === null || targetInput === void 0 ? void 0 : targetInput.focus();
                            }
                        });
                        return;
                    }
                }
                this.keyboardNav.handleCellNavigation(e, input, row, (direction) => {
                    this.keyboardNav.navigateToCell(row, input, direction);
                });
            }
        }, { signal: this.abortController.signal });
    }
    setupJInput(input, rowId, index, row) {
        // Handle paste event
        input.addEventListener('paste', (e) => {
            const clipboardData = e.clipboardData;
            const text = (clipboardData === null || clipboardData === void 0 ? void 0 : clipboardData.getData('text/plain')) || '';
            if (isTSVData(text)) {
                e.preventDefault();
                this.handleTSVPaste(input, row, text);
            }
            // Otherwise, allow default paste behavior
        }, { signal: this.abortController.signal });
        input.addEventListener('input', () => {
            // Use shared input filter
            const filtered = filterNumericInput(input.value);
            if (filtered !== input.value) {
                input.value = filtered;
            }
            const rowData = this.tableState.getRow(rowId);
            if (rowData) {
                const jValues = [...rowData.jValues];
                const value = parseFloat(input.value);
                if (!isNaN(value)) {
                    jValues[index] = Math.abs(value); // Auto-correct to absolute
                    // Don't sort during input - only update state
                    this.tableState.updateRow(rowId, { jValues });
                }
            }
            // Clear error on input (real-time clearing, no new errors shown)
            this.validationState.clearError(`j${index}-${rowId}`);
        }, { signal: this.abortController.signal });
        // J-value sorting removed - will be handled when Generate Text is clicked
        input.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                this.focusNextTableCell(input, row, e.shiftKey);
            }
            else if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                // Check if ArrowDown at last row
                if (e.key === 'ArrowDown') {
                    const isLastRow = !row.nextElementSibling || row.nextElementSibling.classList.contains('add-row-footer');
                    if (isLastRow) {
                        e.preventDefault();
                        const newId = this.tableState.addRow();
                        requestAnimationFrame(() => {
                            const newRow = this.rowElements.get(newId);
                            if (newRow) {
                                const cellIndex = Array.from(row.children).indexOf(input.closest('td'));
                                const targetCell = newRow.children[cellIndex];
                                const targetInput = targetCell === null || targetCell === void 0 ? void 0 : targetCell.querySelector('input');
                                targetInput === null || targetInput === void 0 ? void 0 : targetInput.focus();
                            }
                        });
                        return;
                    }
                }
                this.keyboardNav.handleCellNavigation(e, input, row, (direction) => {
                    this.keyboardNav.navigateToCell(row, input, direction);
                });
            }
        }, { signal: this.abortController.signal });
    }
    setupIntegrationInput(input, rowId, row) {
        // Handle paste event
        input.addEventListener('paste', (e) => {
            const clipboardData = e.clipboardData;
            const text = (clipboardData === null || clipboardData === void 0 ? void 0 : clipboardData.getData('text/plain')) || '';
            if (isTSVData(text)) {
                e.preventDefault();
                this.handleTSVPaste(input, row, text);
            }
            // Otherwise, allow default paste behavior
        }, { signal: this.abortController.signal });
        input.addEventListener('input', () => {
            // Use shared input filter
            const filtered = filterNumericInput(input.value);
            if (filtered !== input.value) {
                input.value = filtered;
            }
            const value = parseFloat(input.value);
            this.tableState.updateRow(rowId, { integration: isNaN(value) ? 0 : value });
            // Clear error on input (real-time clearing, no new errors shown)
            this.validationState.clearError(`int-${rowId}`);
        }, { signal: this.abortController.signal });
        input.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                this.focusNextTableCell(input, row, e.shiftKey);
            }
            else if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                // Check if ArrowDown at last row
                if (e.key === 'ArrowDown') {
                    const isLastRow = !row.nextElementSibling || row.nextElementSibling.classList.contains('add-row-footer');
                    if (isLastRow) {
                        e.preventDefault();
                        const newId = this.tableState.addRow();
                        requestAnimationFrame(() => {
                            const newRow = this.rowElements.get(newId);
                            if (newRow) {
                                const targetInput = newRow.querySelector('.int-input');
                                targetInput === null || targetInput === void 0 ? void 0 : targetInput.focus();
                            }
                        });
                        return;
                    }
                }
                this.keyboardNav.handleCellNavigation(e, input, row, (direction) => {
                    this.keyboardNav.navigateToCell(row, input, direction);
                });
            }
        }, { signal: this.abortController.signal });
    }
    setupAssignmentInput(input, rowId, row) {
        // Paste filtering
        input.addEventListener('paste', (e) => {
            const clipboardData = e.clipboardData;
            const text = (clipboardData === null || clipboardData === void 0 ? void 0 : clipboardData.getData('text/plain')) || '';
            // Check if TSV data
            if (isTSVData(text)) {
                e.preventDefault();
                this.handleTSVPaste(input, row, text);
                return;
            }
            // Otherwise, handle as rich text paste (existing behavior)
            e.preventDefault();
            const htmlText = (clipboardData === null || clipboardData === void 0 ? void 0 : clipboardData.getData('text/html')) || (clipboardData === null || clipboardData === void 0 ? void 0 : clipboardData.getData('text/plain')) || '';
            const temp = document.createElement('div');
            temp.innerHTML = htmlText;
            const filtered = filterHTMLTags(temp, ['B', 'I', 'SUB', 'SUP']);
            document.execCommand('insertHTML', false, filtered);
        }, { signal: this.abortController.signal });
        input.addEventListener('input', () => {
            const html = input.innerHTML.trim() === '' || input.innerHTML === '<br>' ? '' : input.innerHTML;
            this.tableState.updateRow(rowId, { assignment: html });
            // Clear error on input (real-time clearing, no new errors shown)
            this.validationState.clearError(`assignment-${rowId}`);
        }, { signal: this.abortController.signal });
        input.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                if (e.shiftKey) {
                    const prevRow = row.previousElementSibling;
                    if (prevRow) {
                        const prevAssignment = prevRow.querySelector('.assignment-input');
                        prevAssignment === null || prevAssignment === void 0 ? void 0 : prevAssignment.focus();
                    }
                }
                else {
                    const nextRow = row.nextElementSibling;
                    if (nextRow && !nextRow.classList.contains('add-row-footer')) {
                        const nextAssignment = nextRow.querySelector('.assignment-input');
                        nextAssignment === null || nextAssignment === void 0 ? void 0 : nextAssignment.focus();
                    }
                    else {
                        // Last row: add new row
                        const newId = this.tableState.addRow();
                        requestAnimationFrame(() => {
                            const newRow = this.rowElements.get(newId);
                            if (newRow) {
                                const newAssignment = newRow.querySelector('.assignment-input');
                                newAssignment === null || newAssignment === void 0 ? void 0 : newAssignment.focus();
                            }
                        });
                    }
                }
            }
            else if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                // Check if ArrowDown at last row
                if (e.key === 'ArrowDown') {
                    const isLastRow = !row.nextElementSibling || row.nextElementSibling.classList.contains('add-row-footer');
                    if (isLastRow) {
                        e.preventDefault();
                        const newId = this.tableState.addRow();
                        requestAnimationFrame(() => {
                            const newRow = this.rowElements.get(newId);
                            if (newRow) {
                                const nextAssignment = newRow.querySelector('.assignment-input');
                                nextAssignment === null || nextAssignment === void 0 ? void 0 : nextAssignment.focus();
                            }
                        });
                        return;
                    }
                }
                // Check if ArrowRight at end of text
                if (e.key === 'ArrowRight') {
                    const selection = window.getSelection();
                    if (selection && selection.rangeCount > 0) {
                        const isAtEnd = this.isCaretAtEnd(input);
                        if (isAtEnd) {
                            e.preventDefault();
                            const nextRow = row.nextElementSibling;
                            if (nextRow && !nextRow.classList.contains('add-row-footer')) {
                                const nextShift = nextRow.querySelector('.shift-input');
                                nextShift === null || nextShift === void 0 ? void 0 : nextShift.focus();
                            }
                            else {
                                // Last row: add new row
                                const newId = this.tableState.addRow();
                                requestAnimationFrame(() => {
                                    const newRow = this.rowElements.get(newId);
                                    if (newRow) {
                                        const firstInput = newRow.querySelector('.shift-input');
                                        firstInput === null || firstInput === void 0 ? void 0 : firstInput.focus();
                                    }
                                });
                            }
                            return;
                        }
                    }
                }
                // Handle arrow key navigation for contenteditable
                this.keyboardNav.handleCellNavigation(e, input, row, (direction) => {
                    this.keyboardNav.navigateToCell(row, input, direction);
                });
            }
            // Keyboard shortcuts
            if (e.ctrlKey || e.metaKey) {
                if (e.key === 'b' || e.key === 'B') {
                    e.preventDefault();
                    document.execCommand('bold');
                }
                else if (e.key === 'i' || e.key === 'I') {
                    e.preventDefault();
                    document.execCommand('italic');
                }
            }
        }, { signal: this.abortController.signal });
        // Ensure placeholder shows when field is empty on blur
        input.addEventListener('blur', () => {
            var _a;
            const text = ((_a = input.textContent) === null || _a === void 0 ? void 0 : _a.trim()) || '';
            if (text === '') {
                input.innerHTML = '';
            }
        }, { signal: this.abortController.signal });
    }
    setupDeleteButton(button, rowId) {
        button.addEventListener('click', (e) => {
            e.preventDefault();
            this.tableState.removeRows([rowId]);
        }, { signal: this.abortController.signal });
    }
    focusNextTableCell(currentInput, currentRow, reverse) {
        const currentCell = currentInput.closest('td');
        if (!currentCell)
            return;
        const cellIndex = Array.from(currentRow.children).indexOf(currentCell);
        if (reverse) {
            // Move up
            let searchRow = currentRow.previousElementSibling;
            while (searchRow) {
                const targetCell = searchRow.children[cellIndex];
                if (targetCell) {
                    const targetInput = targetCell.querySelector('input:not([disabled]), [contenteditable="true"]');
                    if (targetInput && !targetInput.disabled) {
                        targetInput.focus();
                        return;
                    }
                }
                searchRow = searchRow.previousElementSibling;
            }
        }
        else {
            // Move down
            let searchRow = currentRow.nextElementSibling;
            while (searchRow) {
                const targetCell = searchRow.children[cellIndex];
                if (targetCell) {
                    const targetInput = targetCell.querySelector('input:not([disabled]), [contenteditable="true"]');
                    if (targetInput && !targetInput.disabled) {
                        targetInput.focus();
                        return;
                    }
                }
                searchRow = searchRow.nextElementSibling;
            }
            // No cell below: add new row
            const newId = this.tableState.addRow();
            requestAnimationFrame(() => {
                const newRow = this.rowElements.get(newId);
                if (newRow) {
                    const targetCell = newRow.children[cellIndex];
                    const targetInput = targetCell === null || targetCell === void 0 ? void 0 : targetCell.querySelector('input:not([disabled]), [contenteditable="true"]');
                    if (targetInput && !targetInput.disabled) {
                        targetInput.focus();
                    }
                    else {
                        // Find first enabled input
                        const firstInput = newRow.querySelector('input:not([disabled]), [contenteditable="true"]');
                        firstInput === null || firstInput === void 0 ? void 0 : firstInput.focus();
                    }
                }
            });
        }
    }
    updateJInputsForRow(row, jValues) {
        const jInputs = row.querySelectorAll('.j-input:not([disabled])');
        jInputs.forEach((input, index) => {
            if (index < jValues.length) {
                input.value = jValues[index].toString();
            }
        });
    }
    updateJColumnVisibility() {
        const rows = this.tableState.getRows();
        // Calculate required J columns for each row
        const rowRequirements = [];
        rows.forEach(rowData => {
            const required = this.calculateRequiredJColumns(rowData.multiplicity);
            rowRequirements.push(required);
        });
        // Determine table-wide maximum
        const tableMaxJ = Math.max(0, ...rowRequirements);
        this.maxJColumns = tableMaxJ;
        // Update visibility for all rows
        this.rowElements.forEach((tr, rowId) => {
            const rowData = rows.find(r => r.id === rowId);
            if (!rowData)
                return;
            const jCells = tr.querySelectorAll('.j-input-cell');
            const requiredForRow = this.calculateRequiredJColumns(rowData.multiplicity);
            jCells.forEach((cell, cellIndex) => {
                const input = cell.querySelector('.j-input');
                if (cellIndex < requiredForRow) {
                    // Active cell
                    cell.style.display = '';
                    cell.classList.remove('disabled');
                    if (input)
                        input.disabled = false;
                }
                else if (cellIndex < tableMaxJ) {
                    // Placeholder cell
                    cell.style.display = '';
                    cell.classList.add('disabled');
                    if (input)
                        input.disabled = true;
                }
                else {
                    // Hidden cell
                    cell.style.display = 'none';
                    if (input)
                        input.disabled = true;
                }
            });
        });
        this.updateTableHeader();
        // Re-render footer to update colspan based on new maxJColumns
        this.renderAddRowFooter();
    }
    calculateRequiredJColumns(multiplicity) {
        if (!multiplicity || multiplicity.trim() === '') {
            return 0;
        }
        try {
            // Use NMRPeak.multipletnumbers directly
            const jCounts = NMRPeak.multipletnumbers(multiplicity.trim());
            if (jCounts === null) {
                return 0;
            }
            return jCounts.length;
        }
        catch (_a) {
            return 0;
        }
    }
    updateTableHeader() {
        const thead = this.tableElement.querySelector('thead tr');
        if (!thead)
            return;
        // Remove existing J headers
        const existingJHeaders = thead.querySelectorAll('.j-header');
        existingJHeaders.forEach(header => header.remove());
        // Add J headers before Integration
        const intHeader = thead.querySelector('.integration-header');
        if (intHeader) {
            for (let i = 0; i < this.maxJColumns; i++) {
                const jHeader = document.createElement('th');
                jHeader.className = 'j-header';
                jHeader.textContent = `J${i + 1} (Hz)`;
                intHeader.insertAdjacentElement('beforebegin', jHeader);
            }
        }
    }
    isCaretAtEnd(element) {
        const selection = window.getSelection();
        if (!selection || selection.rangeCount === 0)
            return false;
        const range = selection.getRangeAt(0);
        // Check if selection is collapsed (cursor, not selection)
        if (!range.collapsed)
            return false;
        // Create a range from current position to end of element
        const testRange = document.createRange();
        testRange.selectNodeContents(element);
        testRange.setStart(range.endContainer, range.endOffset);
        // If range is empty, we're at the end
        return testRange.toString().length === 0;
    }
    getFirstInput() {
        const firstRow = this.tableBody.querySelector('tr');
        if (firstRow) {
            return firstRow.querySelector('.shift-input');
        }
        return null;
    }
    /**
     * Clean up event listeners and resources
     * Should be called when the component is destroyed
     */
    destroy() {
        // Abort all event listeners attached with AbortController
        this.abortController.abort();
        // Clear row elements map
        this.rowElements.clear();
        // Create new AbortController for potential reuse
        this.abortController = new AbortController();
    }
}

/**
 * Rich Text Editor Component
 * Displays formatted NMR text output
 */
class RichTextEditor {
    constructor() {
        this.element = document.getElementById('rich-text-editor');
    }
    setContent(html) {
        this.element.innerHTML = html;
    }
    getContent() {
        return this.element.innerHTML;
    }
    clear() {
        this.element.innerHTML = '';
    }
    showPlaceholder(message = 'No valid peaks to display. Add peak data in the table above.') {
        this.element.innerHTML = `<span style="color: #999;">${message}</span>`;
    }
    showError(message) {
        this.element.innerHTML = `<span style="color: red;">Error: ${message}</span>`;
    }
}

/**
 * Formatting Toolbar Component
 * Handles bold, italic, subscript, superscript, and en-dash formatting
 */
class Toolbar {
    constructor() {
        // AbortController for cleaning up event listeners
        this.abortController = new AbortController();
        this.buttons = {
            bold: document.getElementById('format-bold-btn'),
            italic: document.getElementById('format-italic-btn'),
            sub: document.getElementById('format-sub-btn'),
            sup: document.getElementById('format-sup-btn'),
            endash: document.getElementById('insert-endash-btn')
        };
        this.initializeEventListeners();
        this.initializeFocusTracking();
    }
    initializeEventListeners() {
        // Use mousedown to prevent blur on contenteditable fields
        this.buttons.bold.addEventListener('mousedown', (e) => {
            e.preventDefault();
            this.applyFormatting('bold');
        }, { signal: this.abortController.signal });
        this.buttons.italic.addEventListener('mousedown', (e) => {
            e.preventDefault();
            this.applyFormatting('italic');
        }, { signal: this.abortController.signal });
        this.buttons.sub.addEventListener('mousedown', (e) => {
            e.preventDefault();
            this.applyFormatting('subscript');
        }, { signal: this.abortController.signal });
        this.buttons.sup.addEventListener('mousedown', (e) => {
            e.preventDefault();
            this.applyFormatting('superscript');
        }, { signal: this.abortController.signal });
        this.buttons.endash.addEventListener('mousedown', (e) => {
            e.preventDefault();
            this.insertEnDash();
        }, { signal: this.abortController.signal });
    }
    initializeFocusTracking() {
        // Track focus changes to update button states
        document.addEventListener('focusin', () => {
            this.updateButtonStates();
        }, { signal: this.abortController.signal });
        document.addEventListener('focusout', () => {
            this.updateButtonStates();
        }, { signal: this.abortController.signal });
        // Initial state
        this.updateButtonStates();
    }
    updateButtonStates() {
        const activeElement = document.activeElement;
        const isRichTextFocused = activeElement === null || activeElement === void 0 ? void 0 : activeElement.classList.contains('input-richtext');
        // Enable/disable buttons based on focus
        Object.values(this.buttons).forEach(button => {
            if (isRichTextFocused) {
                button.classList.remove('disabled');
            }
            else {
                button.classList.add('disabled');
            }
        });
    }
    applyFormatting(command) {
        const activeElement = document.activeElement;
        if (!activeElement || activeElement.getAttribute('contenteditable') !== 'true') {
            return;
        }
        const selection = window.getSelection();
        if (selection && selection.rangeCount > 0) {
            document.execCommand(command, false);
            activeElement.focus();
        }
    }
    insertEnDash() {
        const activeElement = document.activeElement;
        if (!activeElement || activeElement.getAttribute('contenteditable') !== 'true') {
            return;
        }
        document.execCommand('insertHTML', false, '–');
        activeElement.focus();
    }
    /**
     * Clean up event listeners and resources
     * Should be called when the component is destroyed
     */
    destroy() {
        // Abort all event listeners attached with AbortController
        this.abortController.abort();
        // Create new AbortController for potential reuse
        this.abortController = new AbortController();
    }
}

/**
 * ErrorNotification Component
 * Manages error notification banners in the top-right corner with auto-dismiss and stacking support
 */
class ErrorNotification {
    constructor() {
        this.notifications = new Map();
        this.notificationCount = 0;
        this.container = this.createContainer();
        document.body.appendChild(this.container);
    }
    /**
     * Create the notification container element
     */
    createContainer() {
        const container = document.createElement('div');
        container.className = 'notification-container';
        return container;
    }
    /**
     * Show an error notification banner
     * @param options Notification configuration
     * @returns Notification ID for programmatic dismissal
     */
    show(options) {
        var _a;
        const id = `notification-${++this.notificationCount}`;
        const duration = (_a = options.duration) !== null && _a !== void 0 ? _a : 5000; // Default 5 seconds
        const notification = this.createNotification(id, options.message);
        this.notifications.set(id, notification);
        this.container.appendChild(notification);
        // Trigger reflow for CSS transition
        void notification.offsetHeight;
        notification.classList.add('show');
        // Auto-dismiss if duration > 0
        if (duration > 0) {
            setTimeout(() => {
                this.dismiss(id);
            }, duration);
        }
        return id;
    }
    /**
     * Create a notification element
     */
    createNotification(id, message) {
        const notification = document.createElement('div');
        notification.className = 'error-notification';
        notification.setAttribute('data-notification-id', id);
        const messageSpan = document.createElement('span');
        messageSpan.className = 'notification-message';
        messageSpan.textContent = message;
        const closeButton = document.createElement('button');
        closeButton.className = 'notification-close';
        closeButton.innerHTML = '&times;';
        closeButton.setAttribute('aria-label', 'Close notification');
        closeButton.addEventListener('click', () => {
            this.dismiss(id);
        });
        notification.appendChild(messageSpan);
        notification.appendChild(closeButton);
        return notification;
    }
    /**
     * Dismiss a notification by ID
     */
    dismiss(id) {
        const notification = this.notifications.get(id);
        if (!notification)
            return;
        notification.classList.remove('show');
        notification.classList.add('hide');
        // Remove from DOM after transition
        setTimeout(() => {
            if (notification.parentNode) {
                this.container.removeChild(notification);
            }
            this.notifications.delete(id);
        }, 300); // Match CSS transition duration
    }
    /**
     * Dismiss all notifications
     */
    dismissAll() {
        for (const id of this.notifications.keys()) {
            this.dismiss(id);
        }
    }
    /**
     * Clean up and remove the notification container
     */
    destroy() {
        this.dismissAll();
        if (this.container.parentNode) {
            document.body.removeChild(this.container);
        }
    }
}

/**
 * DragDropHandler Component
 * Manages drag-and-drop functionality for file import with visual feedback
 */
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
class DragDropHandler {
    constructor(options) {
        this.dragCounter = 0;
        this.targetElement = options.targetElement;
        this.errorNotification = options.errorNotification;
        this.onFilesDropped = options.onFilesDropped;
        this.overlay = this.createOverlay();
        this.initializeEventListeners();
    }
    /**
     * Create the drag-drop overlay element
     */
    createOverlay() {
        const overlay = document.createElement('div');
        overlay.className = 'drag-drop-overlay';
        overlay.innerHTML = `
      <div class="drag-drop-content">
        <div class="drag-drop-icon">📁</div>
        <div class="drag-drop-text">Drop Here</div>
      </div>
    `;
        overlay.style.display = 'none';
        this.targetElement.appendChild(overlay);
        return overlay;
    }
    /**
     * Initialize drag-and-drop event listeners
     */
    initializeEventListeners() {
        // Prevent default drag behaviors on the target element
        this.targetElement.addEventListener('dragenter', this.handleDragEnter.bind(this));
        this.targetElement.addEventListener('dragover', this.handleDragOver.bind(this));
        this.targetElement.addEventListener('dragleave', this.handleDragLeave.bind(this));
        this.targetElement.addEventListener('drop', this.handleDrop.bind(this));
        // Prevent overlay from interfering with drag events
        this.overlay.addEventListener('dragenter', (e) => e.preventDefault());
        this.overlay.addEventListener('dragover', (e) => e.preventDefault());
    }
    /**
     * Handle dragenter event
     */
    handleDragEnter(e) {
        e.preventDefault();
        e.stopPropagation();
        this.dragCounter++;
        // Only show overlay on first dragenter
        if (this.dragCounter === 1) {
            this.showOverlay();
        }
    }
    /**
     * Handle dragover event
     */
    handleDragOver(e) {
        e.preventDefault();
        e.stopPropagation();
    }
    /**
     * Handle dragleave event
     */
    handleDragLeave(e) {
        e.preventDefault();
        e.stopPropagation();
        this.dragCounter--;
        // Only hide overlay when all drags have left
        if (this.dragCounter === 0) {
            this.hideOverlay();
        }
    }
    /**
     * Handle drop event
     */
    async handleDrop(e) {
        e.preventDefault();
        e.stopPropagation();
        this.dragCounter = 0;
        this.hideOverlay();
        try {
            const files = await this.extractFilesFromDrop(e);
            if (files.length === 0) {
                this.errorNotification.show({
                    message: 'No File Found.',
                    duration: 3000
                });
                return;
            }
            // Log all file names
            console.log('Dropped files:');
            files.forEach(file => console.log(file.name));
            // Validate files (currently all files are rejected as specified)
            this.validateFiles(files);
            // Call the callback if provided
            if (this.onFilesDropped) {
                this.onFilesDropped(files);
            }
        }
        catch (error) {
            console.error('Error processing dropped files:', error);
            this.errorNotification.show({
                message: 'Error reading files. Please try again.',
                duration: 5000
            });
        }
    }
    /**
     * Extract files from drag event
     */
    async extractFilesFromDrop(e) {
        var _a;
        const files = [];
        if (!((_a = e.dataTransfer) === null || _a === void 0 ? void 0 : _a.items)) {
            return files;
        }
        const items = Array.from(e.dataTransfer.items);
        for (const item of items) {
            if (item.kind !== 'file')
                continue;
            try {
                // Use File System Access API
                const handle = await item.getAsFileSystemHandle();
                if (handle.kind === 'directory') {
                    // Recursively read directory
                    const dirFiles = await this.readDirectoryHandle(handle);
                    files.push(...dirFiles);
                }
                else if (handle.kind === 'file') {
                    // Read single file
                    const file = await handle.getFile();
                    files.push(file);
                }
            }
            catch (error) {
                console.error('Error reading dropped item:', error);
                // Fallback: try getAsFile() for single files
                const file = item.getAsFile();
                if (file)
                    files.push(file);
            }
        }
        return files;
    }
    /**
     * Read directory using File System Access API (modern)
     */
    async readDirectoryHandle(dirHandle) {
        var _a, e_1, _b, _c;
        const files = [];
        try {
            try {
                for (var _d = true, _e = __asyncValues(dirHandle.values()), _f; _f = await _e.next(), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const entry = _c;
                    if (entry.kind === 'file') {
                        const file = await entry.getFile();
                        files.push(file);
                    }
                    else if (entry.kind === 'directory') {
                        // Recursively read subdirectory
                        const subFiles = await this.readDirectoryHandle(entry);
                        files.push(...subFiles);
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) await _b.call(_e);
                }
                finally { if (e_1) throw error; }
            }
        }
        catch (error) {
            console.error(`Error reading directory ${dirHandle.name}:`, error);
        }
        return files;
    }
    /**
     * Validate dropped files
     * Currently rejects all files as per step 2 (skip for now)
     */
    validateFiles(files) {
        // Check if this is TopSpin data
        if (isTopSpinData(files)) {
            // TopSpin data detected - will be handled by onFilesDropped callback
            return;
        }
        // For now, reject all other files with an error message
        for (const file of files) {
            this.errorNotification.show({
                message: `File "${file.name}" is not supported.`,
                duration: 5000
            });
        }
    }
    /**
     * Show the drag-drop overlay
     */
    showOverlay() {
        this.overlay.style.display = 'flex';
        // Trigger reflow for CSS transition
        void this.overlay.offsetHeight;
        this.overlay.classList.add('show');
    }
    /**
     * Hide the drag-drop overlay
     */
    hideOverlay() {
        this.overlay.classList.remove('show');
        setTimeout(() => {
            this.overlay.style.display = 'none';
        }, 200); // Match CSS transition duration
    }
    /**
     * Clean up event listeners and remove overlay
     */
    destroy() {
        this.targetElement.removeEventListener('dragenter', this.handleDragEnter.bind(this));
        this.targetElement.removeEventListener('dragover', this.handleDragOver.bind(this));
        this.targetElement.removeEventListener('dragleave', this.handleDragLeave.bind(this));
        this.targetElement.removeEventListener('drop', this.handleDrop.bind(this));
        if (this.overlay.parentNode) {
            this.targetElement.removeChild(this.overlay);
        }
    }
}

// ========== NAVIGATION ==========
/**
 * Focus Manager
 * Manages focus order and navigation between form fields
 */
class FocusManager {
    constructor(metadataFields, onExitMetadataToTable) {
        this.metadataFields = [];
        this.metadataFields = metadataFields;
        this.onExitMetadataToTable = onExitMetadataToTable;
    }
    /**
     * Focus next metadata field (Tab navigation)
     */
    focusNextMetadataField(currentField, reverse = false) {
        const currentIndex = this.metadataFields.indexOf(currentField);
        if (currentIndex === -1)
            return;
        let targetIndex;
        if (reverse) {
            // Shift+Tab: go to previous field, or wrap to last field
            targetIndex = currentIndex > 0 ? currentIndex - 1 : this.metadataFields.length - 1;
        }
        else {
            // Tab: go to next field, or jump to table
            if (currentIndex < this.metadataFields.length - 1) {
                targetIndex = currentIndex + 1;
            }
            else {
                // Last metadata field: jump to table
                if (this.onExitMetadataToTable) {
                    this.onExitMetadataToTable();
                }
                return;
            }
        }
        const targetField = this.metadataFields[targetIndex];
        if (targetField) {
            targetField.focus();
            // Select all content on Tab navigation
            this.selectAll(targetField);
        }
    }
    /**
     * Move cursor to end of contenteditable element
     */
    moveCursorToEnd(element) {
        var _a;
        const range = document.createRange();
        const sel = window.getSelection();
        if (element.childNodes.length > 0) {
            const lastNode = element.childNodes[element.childNodes.length - 1];
            if (lastNode.nodeType === Node.TEXT_NODE) {
                range.setStart(lastNode, ((_a = lastNode.textContent) === null || _a === void 0 ? void 0 : _a.length) || 0);
            }
            else {
                range.setStartAfter(lastNode);
            }
            range.collapse(true);
            sel === null || sel === void 0 ? void 0 : sel.removeAllRanges();
            sel === null || sel === void 0 ? void 0 : sel.addRange(range);
        }
    }
    /**
     * Move cursor to start of contenteditable element
     */
    moveCursorToStart(element) {
        const range = document.createRange();
        const sel = window.getSelection();
        if (element.childNodes.length > 0) {
            range.setStart(element.childNodes[0], 0);
            range.collapse(true);
            sel === null || sel === void 0 ? void 0 : sel.removeAllRanges();
            sel === null || sel === void 0 ? void 0 : sel.addRange(range);
        }
    }
    /**
     * Select all content in contenteditable element
     */
    selectAll(element) {
        const range = document.createRange();
        const sel = window.getSelection();
        range.selectNodeContents(element);
        sel === null || sel === void 0 ? void 0 : sel.removeAllRanges();
        sel === null || sel === void 0 ? void 0 : sel.addRange(range);
    }
}

/**
 * Keyboard Navigation
 * Handles arrow key navigation within table cells and other complex navigation
 */
class KeyboardNav {
    /**
     * Handle arrow key navigation between table cells
     */
    handleCellNavigation(e, currentInput, currentRow, onNavigate) {
        const key = e.key;
        // Handle Tab navigation (handled by browser default + custom logic)
        if (key === 'Tab') {
            return; // Let default or custom Tab handlers manage this
        }
        // Arrow key navigation
        if (key === 'ArrowUp' || key === 'ArrowDown' || key === 'ArrowLeft' || key === 'ArrowRight') {
            const isContentEditable = currentInput.getAttribute('contenteditable') === 'true';
            if (isContentEditable) {
                this.handleContentEditableArrowKeys(e, currentInput, onNavigate);
            }
            else if (currentInput.type === 'number') {
                this.handleNumberInputArrowKeys(e, onNavigate);
            }
            else {
                this.handleTextInputArrowKeys(e, currentInput, onNavigate);
            }
        }
    }
    handleContentEditableArrowKeys(e, currentInput, onNavigate) {
        const selection = window.getSelection();
        const range = selection && selection.rangeCount > 0 ? selection.getRangeAt(0) : null;
        const text = currentInput.textContent || '';
        const cursorPosition = range ? range.startOffset : 0;
        if (e.key === 'ArrowUp') {
            e.preventDefault();
            onNavigate('up');
        }
        else if (e.key === 'ArrowDown') {
            e.preventDefault();
            onNavigate('down');
        }
        else if (e.key === 'ArrowRight' && cursorPosition >= text.length) {
            e.preventDefault();
            onNavigate('right');
        }
        else if (e.key === 'ArrowLeft' && cursorPosition === 0) {
            e.preventDefault();
            onNavigate('left');
        }
    }
    handleNumberInputArrowKeys(e, onNavigate) {
        // For number inputs, always override arrow keys for navigation
        if (e.key === 'ArrowUp') {
            e.preventDefault();
            onNavigate('up');
        }
        else if (e.key === 'ArrowDown') {
            e.preventDefault();
            onNavigate('down');
        }
        else if (e.key === 'ArrowRight') {
            e.preventDefault();
            onNavigate('right');
        }
        else if (e.key === 'ArrowLeft') {
            e.preventDefault();
            onNavigate('left');
        }
    }
    handleTextInputArrowKeys(e, currentInput, onNavigate) {
        const cursorPosition = currentInput.selectionStart || 0;
        const text = currentInput.value || '';
        if (e.key === 'ArrowUp') {
            e.preventDefault();
            onNavigate('up');
        }
        else if (e.key === 'ArrowDown') {
            e.preventDefault();
            onNavigate('down');
        }
        else if (e.key === 'ArrowRight' && cursorPosition >= text.length) {
            e.preventDefault();
            onNavigate('right');
        }
        else if (e.key === 'ArrowLeft' && cursorPosition === 0) {
            e.preventDefault();
            onNavigate('left');
        }
    }
    /**
     * Navigate to adjacent cell in table
     */
    navigateToCell(currentRow, currentInput, direction) {
        const currentCell = currentInput.closest('td');
        if (!currentCell)
            return;
        if (direction === 'up' || direction === 'down') {
            this.navigateVertical(currentRow, currentCell, direction);
        }
        else {
            this.navigateHorizontal(currentRow, currentCell, direction);
        }
    }
    navigateVertical(currentRow, currentCell, direction) {
        const targetRow = direction === 'up'
            ? currentRow.previousElementSibling
            : currentRow.nextElementSibling;
        if (!targetRow)
            return;
        const cellIndex = Array.from(currentRow.children).indexOf(currentCell);
        const targetCell = targetRow.children[cellIndex];
        if (targetCell) {
            const targetInput = targetCell.querySelector('input, [contenteditable="true"]');
            targetInput === null || targetInput === void 0 ? void 0 : targetInput.focus();
        }
    }
    navigateHorizontal(currentRow, currentCell, direction) {
        var _a;
        // Find all visible, enabled cells
        const allCells = Array.from(currentRow.querySelectorAll('td:not(.checkbox-cell)'));
        const visibleCells = allCells.filter(cell => {
            if (cell.style.display === 'none')
                return false;
            const input = cell.querySelector('input, [contenteditable="true"]');
            if (!input)
                return false;
            if (input.disabled)
                return false;
            return true;
        });
        const currentIndex = visibleCells.indexOf(currentCell);
        if (currentIndex === -1)
            return;
        const targetIndex = direction === 'right' ? currentIndex + 1 : currentIndex - 1;
        if (targetIndex < 0 || targetIndex >= visibleCells.length)
            return;
        const targetCell = visibleCells[targetIndex];
        const targetInput = targetCell.querySelector('input:not([disabled]), [contenteditable="true"]');
        if (targetInput) {
            targetInput.focus();
            // Set cursor position for contenteditable
            if (targetInput.getAttribute('contenteditable') === 'true') {
                const range = document.createRange();
                const sel = window.getSelection();
                const textNode = targetInput.firstChild;
                if (textNode && textNode.nodeType === Node.TEXT_NODE) {
                    if (direction === 'right') {
                        range.setStart(textNode, 0);
                    }
                    else {
                        range.setStart(textNode, ((_a = textNode.textContent) === null || _a === void 0 ? void 0 : _a.length) || 0);
                    }
                    range.collapse(true);
                    sel === null || sel === void 0 ? void 0 : sel.removeAllRanges();
                    sel === null || sel === void 0 ? void 0 : sel.addRange(range);
                }
            }
            else if (targetInput.type !== 'number') {
                // Set cursor position for text inputs
                const input = targetInput;
                if (direction === 'right') {
                    input.setSelectionRange(0, 0);
                }
                else {
                    const len = input.value.length;
                    input.setSelectionRange(len, len);
                }
            }
        }
    }
}

// ========== MAIN APPLICATION ==========
/**
 * Main Application
 * Orchestrates all components and manages application lifecycle
 */
// Import from existing modules
class NMRFormatterApp {
    constructor() {
        this.appState = new AppState();
        // Initialize focus manager
        this.focusManager = new FocusManager([], () => {
            const firstInput = this.nmrTable.getFirstInput();
            firstInput === null || firstInput === void 0 ? void 0 : firstInput.focus();
        });
        // Initialize metadata form
        this.metadataForm = new MetadataForm(this.appState.metadata, this.appState.validation, (currentField, reverse) => {
            this.focusManager.focusNextMetadataField(currentField, reverse);
        }, () => {
            // Regenerate formatted text when sort order changes
            this.generateFormattedText();
        });
        // Update focus manager with metadata fields
        this.focusManager = new FocusManager(this.metadataForm.getFieldOrder(), () => {
            const firstInput = this.nmrTable.getFirstInput();
            firstInput === null || firstInput === void 0 ? void 0 : firstInput.focus();
        });
        // Initialize NMR table
        this.nmrTable = new NMRTable(this.appState.table, this.appState.validation, () => {
            // On multiplicity change
            this.appState.validation.clearAllErrors();
        }, (reverse) => {
            var _a;
            // On navigate to metadata
            const fields = this.metadataForm.getFieldOrder();
            if (reverse) {
                (_a = fields[fields.length - 1]) === null || _a === void 0 ? void 0 : _a.focus();
            }
        });
        // Initialize rich text editor
        this.richTextEditor = new RichTextEditor();
        // Initialize toolbar
        this.toolbar = new Toolbar();
        // Initialize error notification system
        this.errorNotification = new ErrorNotification();
        // Initialize drag-drop handler for table container
        const tableContainer = document.querySelector('.table-container');
        if (tableContainer) {
            this.dragDropHandler = new DragDropHandler({
                targetElement: tableContainer,
                errorNotification: this.errorNotification,
                onFilesDropped: async (files) => {
                    console.log('Files dropped:', files.map(f => f.name));
                    await this.handleTopSpinImport(files);
                }
            });
        }
        // Initialize event listeners
        this.initializeEventListeners();
    }
    initializeEventListeners() {
        // Convert down button (Table → Rich Text)
        const convertDownBtn = document.getElementById('convert-down-btn');
        convertDownBtn === null || convertDownBtn === void 0 ? void 0 : convertDownBtn.addEventListener('click', () => {
            this.generateFormattedText();
        });
        // Copy button
        const copyBtn = document.getElementById('copy-btn');
        copyBtn === null || copyBtn === void 0 ? void 0 : copyBtn.addEventListener('click', () => {
            this.copyFormattedText();
        });
    }
    generateFormattedText() {
        try {
            // Get metadata
            const metadataData = this.appState.metadata.getData();
            const metadata = new Metadata(metadataData.nuclei, // HTML content as nuclei type
            metadataData.solvent, // HTML content as solvent type
            metadataData.frequency);
            // Sort all J-values in descending order
            this.appState.table.sortAllJValues();
            // Remove empty rows from table
            this.appState.table.removeEmptyRows();
            // Validate and highlight errors (after removing empty rows)
            const hasErrors = this.validateAndHighlightTable();
            // Get peaks from table state
            const tableRows = this.appState.table.getRows();
            const peaks = [];
            tableRows.forEach(row => {
                const shift = parseChemicalShift(row.shift);
                const multiplicity = convertMultiplicityToText(row.multiplicity);
                if (shift !== null) {
                    const peak = new NMRPeak(shift, multiplicity, row.jValues, row.integration, row.assignment);
                    peaks.push(peak);
                }
            });
            if (peaks.length === 0) {
                this.richTextEditor.showPlaceholder();
                return;
            }
            // Sort peaks by chemical shift
            sortPeaksByShift(peaks, metadataData.sortOrder);
            const nmrData = new NMRData(peaks, metadata);
            // Generate formatted text
            const formattedText = generateFormattedText(nmrData, metadataData.shiftPrecision, metadataData.jPrecision, 0);
            this.richTextEditor.setContent(formattedText);
            if (hasErrors) {
                console.log('Generated text with validation errors present');
            }
        }
        catch (error) {
            console.error('Error generating formatted text:', error);
            this.richTextEditor.showError(error.message);
        }
    }
    validateAndHighlightTable() {
        let hasErrors = false;
        // Validate metadata
        const metadataData = this.appState.metadata.getData();
        hasErrors = validateMetadata({
            nuclei: metadataData.nuclei,
            solvent: metadataData.solvent,
            frequency: metadataData.frequency
        }, this.appState.validation);
        // Validate table rows
        const tableRows = this.appState.table.getRows();
        const is1HNMR = metadataData.nuclei.includes('1') && metadataData.nuclei.includes('H');
        if (validateTableRows(tableRows, is1HNMR, this.appState.validation)) {
            hasErrors = true;
        }
        return hasErrors;
    }
    /**
     * Handle TopSpin data import
     * @param files - Array of files from drag-and-drop
     */
    async handleTopSpinImport(files) {
        try {
            // Check if files contain TopSpin data
            if (!isTopSpinData(files)) {
                console.log('Not TopSpin data');
                return;
            }
            // Parse TopSpin directory to extract peaks and metadata
            const peaks = await parseTopSpinDirectory(files);
            if (peaks.length === 0) {
                this.errorNotification.show({
                    message: 'No peaks found in TopSpin data.',
                    duration: 5000
                });
                return;
            }
            // Extract metadata from parm.txt
            const parmFile = files.find(f => f.name === 'parm.txt');
            if (parmFile) {
                const parmContent = await parmFile.text();
                const metadata = parseTopSpinMetadata(parmContent);
                // Update metadata state
                if (metadata.nuclei) {
                    this.appState.metadata.setNuclei(metadata.nuclei);
                }
                if (metadata.solvent) {
                    this.appState.metadata.setSolvent(metadata.solvent);
                }
                if (metadata.frequency) {
                    this.appState.metadata.setFrequency(metadata.frequency);
                }
                // Update form fields from state
                this.metadataForm.updateFromState();
            }
            // Sort peaks by chemical shift (descending order - high to low ppm)
            sortPeaksByShift(peaks, 'desc');
            // Clear existing rows and add new peaks
            // Remove all existing rows
            const existingRows = this.appState.table.getRows();
            this.appState.table.removeRows(existingRows.map(row => row.id));
            // Add each peak as a new row
            peaks.forEach(peak => {
                this.appState.table.addRow({
                    shift: peak.shift.toString(),
                    multiplicity: peak.multiplicity,
                    jValues: peak.jValues,
                    integration: typeof peak.integration === 'number' ? peak.integration : parseFloat(peak.integration),
                    assignment: peak.assignment
                });
            });
            // Remove any empty rows (including the initial empty row)
            this.appState.table.removeEmptyRows();
            // Don't auto-generate formatted text - let user review and edit first
            // this.generateFormattedText();
            console.log(`Successfully imported ${peaks.length} peaks from TopSpin data`);
        }
        catch (error) {
            console.error('Error importing TopSpin data:', error);
            this.errorNotification.show({
                message: 'Error importing TopSpin data. Please try again.',
                duration: 5000
            });
        }
    }
    copyFormattedText() {
        const richTextContent = this.richTextEditor.getContent();
        if (!richTextContent || richTextContent.trim() === '') {
            alert('No formatted text to copy. Generate text first.');
            return;
        }
        // Create temporary element to copy HTML content
        const tempElement = document.createElement('div');
        tempElement.innerHTML = richTextContent;
        document.body.appendChild(tempElement);
        // Select the content
        const range = document.createRange();
        range.selectNodeContents(tempElement);
        const selection = window.getSelection();
        selection === null || selection === void 0 ? void 0 : selection.removeAllRanges();
        selection === null || selection === void 0 ? void 0 : selection.addRange(range);
        try {
            // Copy to clipboard
            document.execCommand('copy');
            // Show feedback
            const copyBtn = document.getElementById('copy-btn');
            if (copyBtn) {
                const originalText = copyBtn.textContent;
                copyBtn.textContent = 'Copied!';
                copyBtn.style.backgroundColor = '#28a745';
                copyBtn.style.color = 'white';
                setTimeout(() => {
                    copyBtn.textContent = originalText || 'Copy';
                    copyBtn.style.backgroundColor = '';
                    copyBtn.style.color = '';
                }, 2000);
            }
        }
        catch (error) {
            console.error('Failed to copy:', error);
            alert('Failed to copy to clipboard');
        }
        finally {
            // Clean up
            document.body.removeChild(tempElement);
            selection === null || selection === void 0 ? void 0 : selection.removeAllRanges();
        }
    }
}
// Initialize app when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
    window.app = new NMRFormatterApp();
    console.log('NMR Formatter App initialized (TypeScript version)');
});

// Export to window object for browser usage (legacy support)
window.Logger = Logger;
window.LogLevel = LogLevel;
window.NUCLEI_PRESETS = NUCLEI_PRESETS;
window.SOLVENT_PRESETS = SOLVENT_PRESETS;
window.SORT_ORDER_PRESETS = SORT_ORDER_PRESETS;
window.NUCLEI_CONFIG = NUCLEI_CONFIG;
window.SOLVENT_CONFIG = SOLVENT_CONFIG;
window.getNucleiPatterns = getNucleiPatterns;
window.getSolventPatterns = getSolventPatterns;
window.extractNucleiFromText = extractNucleiFromText;
window.extractSolventFromText = extractSolventFromText;
window.extractNucleiHTMLFromText = extractNucleiHTMLFromText;
window.extractSolventHTMLFromText = extractSolventHTMLFromText;
window.isValidNucleiType = isValidNucleiType;
window.isValidSolventType = isValidSolventType;
window.Metadata = Metadata;
window.NMRPeak = NMRPeak;
window.NMRData = NMRData;
window.multipletnumbers = NMRPeak.multipletnumbers;
window.formatChemicalShift = formatChemicalShift;
window.formatJValues = formatJValues;
window.formatIntegration = formatIntegration;
window.formatMultiplicity = formatMultiplicity;
window.formatAssignment = formatAssignment;
window.formatSinglePeak = formatSinglePeak;
window.formatMetadata = formatMetadata;
window.generateFormattedText = generateFormattedText;
window.isJValuesOptional = NMRPeak.isJValuesOptional;

// Export new classes (State Management & UI)
window.MetadataState = MetadataState;
window.TableState = TableState;
window.ValidationState = ValidationState;
window.AppState = AppState;
window.MetadataForm = MetadataForm;
window.NMRTable = NMRTable;
window.RichTextEditor = RichTextEditor;
window.Toolbar = Toolbar;
window.ErrorNotification = ErrorNotification;
window.DragDropHandler = DragDropHandler;
window.FocusManager = FocusManager;
window.KeyboardNav = KeyboardNav;
window.NMRFormatterApp = NMRFormatterApp;

// Export TSV Parser utilities
window.isTSVData = isTSVData;
window.parseTSV = parseTSV;

// Export TopSpin Parser utilities
window.isTopSpinData = isTopSpinData;
window.parseTopSpinDirectory = parseTopSpinDirectory;
window.parseTopSpinXML = parseTopSpinXML;
window.parseTopSpinMetadata = parseTopSpinMetadata;

console.log('NMR Formatter browser bundle loaded (TypeScript refactored version)');
