// Browser-compatible bundle for NMR Formatter
// Auto-generated by scripts/build-browser.js
// DO NOT EDIT THIS FILE MANUALLY - It will be overwritten on build

// Centralized logging utility
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["DEBUG"] = 0] = "DEBUG";
    LogLevel[LogLevel["INFO"] = 1] = "INFO";
    LogLevel[LogLevel["WARN"] = 2] = "WARN";
    LogLevel[LogLevel["ERROR"] = 3] = "ERROR";
    LogLevel[LogLevel["NONE"] = 4] = "NONE";
})(LogLevel || (LogLevel = {}));
class Logger {
    static setLogLevel(level) {
        this.logLevel = level;
    }
    static debug(message, ...args) {
        if (this.logLevel <= LogLevel.DEBUG) {
            console.log(`[DEBUG] ${message}`, ...args);
        }
    }
    static info(message, ...args) {
        if (this.logLevel <= LogLevel.INFO) {
            console.info(`[INFO] ${message}`, ...args);
        }
    }
    static warn(message, ...args) {
        if (this.logLevel <= LogLevel.WARN) {
            console.warn(`[WARN] ${message}`, ...args);
        }
    }
    static error(message, ...args) {
        if (this.logLevel <= LogLevel.ERROR) {
            console.error(`[ERROR] ${message}`, ...args);
        }
    }
}
Logger.logLevel = LogLevel.INFO;

// Configuration constants for nuclei and solvents
// Nuclei preset configurations
const NUCLEI_PRESETS = [
    { id: "1H", displayHTML: "<sup>1</sup>H", pattern: /(¹H|protone?|1H\s+NMR|NMR\s+1H)/i },
    { id: "2H", displayHTML: "<sup>2</sup>H", pattern: /(²H|deuterium|2H\s+NMR|NMR\s+2H)/i },
    { id: "13C", displayHTML: "<sup>13</sup>C", pattern: /(13C|¹³C|carbon)/i },
    { id: "14N", displayHTML: "<sup>14</sup>N", pattern: /(14N|¹⁴N)/i },
    { id: "15N", displayHTML: "<sup>15</sup>N", pattern: /(15N|¹⁵N)/i },
    { id: "19F", displayHTML: "<sup>19</sup>F", pattern: /(19F|¹⁹F)/i },
    { id: "23Na", displayHTML: "<sup>23</sup>Na", pattern: /(23Na|²³Na)/i },
    { id: "27Al", displayHTML: "<sup>27</sup>Al", pattern: /(27Al|²⁷Al)/i },
    { id: "29Si", displayHTML: "<sup>29</sup>Si", pattern: /(29Si|²⁹Si)/i },
    { id: "31P", displayHTML: "<sup>31</sup>P", pattern: /(31P|³¹P)/i }
];
// Solvent preset configurations
const SOLVENT_PRESETS = [
    { id: "D2O", displayHTML: "D<sub>2</sub>O", pattern: /([DH][2₂]O|water)/i },
    { id: "CD3OD", displayHTML: "CD<sub>3</sub>OD", pattern: /(C[DH][3₃]O[DH]|methanol)/i },
    { id: "CD3CN", displayHTML: "CD<sub>3</sub>CN", pattern: /(C[DH][3₃]CN|acetonitrile?)/i },
    { id: "(CD3)2SO", displayHTML: "DMSO–<I>d</I><sub>6</sub>", pattern: /(\(C[DH][3₃]\)[2₂]SO|Me[2₂]SO|DMSO)/i },
    { id: "(CD3)2CO", displayHTML: "acetone–<I>d</I><sub>6</sub>", pattern: /(\(C[DH][3₃]\)[2₂]CO|Me[2₂]CO|acetone?)/i },
    { id: "C6D6", displayHTML: "C<sub>6</sub>D<sub>6</sub>", pattern: /(C[6₆][DH][6₆]|benzene?)/i },
    { id: "toluene-d8", displayHTML: "toluene–<i>d</i><sub>8</sub>", pattern: /(toluene?)/i },
    { id: "CDCl3", displayHTML: "CDCl<sub>3</sub>", pattern: /(C[DH]Cl[3₃]|ch?loroform)/i },
    { id: "CD2Cl2", displayHTML: "CD<sub>2</sub>Cl<sub>2</sub>", pattern: /(C[DH][2₂]Cl[2₂]|dich?loromethane?)/i },
    { id: "THF-d8", displayHTML: "THF–<i>d</i><sub>8</sub>", pattern: /(THF|tetrahydrofuran)/i }
];
// Legacy Record-based configurations (for backward compatibility)
const NUCLEI_CONFIG = {
    "1H": /(¹H|protone?|1H\s+NMR|NMR\s+1H)/i,
    "2H": /(²H|deuterium|2H\s+NMR|NMR\s+2H)/i,
    "13C": /(13C|¹³C|carbon)/i,
    "14N": /(14N|¹⁴N)/i,
    "15N": /(15N|¹⁵N)/i,
    "19F": /(19F|¹⁹F)/i,
    "23Na": /(23Na|²³Na)/i,
    "27Al": /(27Al|²⁷Al)/i,
    "29Si": /(29Si|²⁹Si)/i,
    "31P": /(31P|³¹P)/i,
    "": null
};
const SOLVENT_CONFIG = {
    "D2O": /([DH][2₂]O|water)/i,
    "CD3OD": /(C[DH][3₃]O[DH]|methanol)/i,
    "CD3CN": /(C[DH][3₃]CN|acetonitrile?)/i,
    "(CD3)2SO": /(\(C[DH][3₃]\)[2₂]SO|Me[2₂]SO|DMSO)/i,
    "(CD3)2CO": /(\(C[DH][3₃]\)[2₂]CO|Me[2₂]CO|acetone?)/i,
    "C6D6": /(C[6₆][DH][6₆]|benzene?)/i,
    "toluene-d8": /(toluene?)/i,
    "CDCl3": /(C[DH]Cl[3₃]|ch?loroform)/i,
    "CD2Cl2": /(C[DH][2₂]Cl[2₂]|dich?loromethane?)/i,
    "THF-d8": /(THF|tetrahydrofuran)/i,
    "": null
};
// Utility functions for pattern access
function getNucleiPatterns() {
    const patterns = {};
    for (const [nuclei, pattern] of Object.entries(NUCLEI_CONFIG)) {
        if (pattern && nuclei !== "") {
            patterns[nuclei] = pattern;
        }
    }
    return patterns;
}
function getSolventPatterns() {
    const patterns = {};
    for (const [solvent, pattern] of Object.entries(SOLVENT_CONFIG)) {
        if (pattern && solvent !== "") {
            patterns[solvent] = pattern;
        }
    }
    return patterns;
}
// Type-safe extraction functions
function extractNucleiFromText(text) {
    for (const [nuclei, pattern] of Object.entries(NUCLEI_CONFIG)) {
        if (pattern && pattern.test(text)) {
            return nuclei;
        }
    }
    return "";
}
function extractSolventFromText(text) {
    for (const [solvent, pattern] of Object.entries(SOLVENT_CONFIG)) {
        if (pattern && pattern.test(text)) {
            return solvent;
        }
    }
    return "";
}
// Type safety validation functions
function isValidNucleiType(value) {
    return Object.keys(NUCLEI_CONFIG).includes(value);
}
function isValidSolventType(value) {
    return Object.keys(SOLVENT_CONFIG).includes(value);
}

// Metadata model for NMR data
class Metadata {
    constructor(nuclei = "", solvent = "", frequency = 0) {
        this.nuclei = nuclei;
        this.solvent = solvent;
        this.frequency = frequency;
    }
}
// Runtime validation functions
function validateNucleiType(nuclei) {
    if (isValidNucleiType(nuclei)) {
        return nuclei;
    }
    Logger.warn(`Invalid nuclei type: ${nuclei}. Falling back to empty string.`);
    return "";
}
function validateSolventType(solvent) {
    if (isValidSolventType(solvent)) {
        return solvent;
    }
    Logger.warn(`Invalid solvent type: ${solvent}. Falling back to empty string.`);
    return "";
}

// NMR Peak model
class NMRPeak {
    constructor(chemicalShift = 0, multiplicity = "", jValues = [], integration = 0, assignment = "") {
        this.chemicalShift = chemicalShift;
        this.multiplicity = multiplicity;
        this.jValues = jValues;
        this.integration = integration;
        this.assignment = assignment;
    }
    // Convenience getter/setter for compatibility with app.js
    get shift() {
        return typeof this.chemicalShift === 'number' ? this.chemicalShift : this.chemicalShift[0];
    }
    set shift(value) {
        this.chemicalShift = value;
    }
}

// NMR Data model
class NMRData {
    constructor(peaks = [], metadata = new Metadata()) {
        this.peaks = peaks;
        this.metadata = metadata;
    }
    addPeak(peak) {
        this.peaks.push(peak);
    }
    removePeak(index) {
        if (index >= 0 && index < this.peaks.length) {
            this.peaks.splice(index, 1);
        }
    }
    updateMetadata(key, value) {
        this.metadata[key] = value;
    }
}

// Validation functions for NMR data
// Regular expression pattern for multiplicity validation
const MULTIPLICITY_PATTERN = /^[a-zA-Z0-9\s\-]+$/;
// Function to get expected number of J-values based on multiplicity
// Returns null for singlet(s), multiplet(m), or broad(br)
// Returns array of expected J-value counts for compound multiplicities (e.g., dt -> [2,3])
function multipletnumbers(multiplicityText) {
    const clean = multiplicityText.toLowerCase().trim();
    let normalized = clean;
    const replacementMap = [
        [/\s+of\s+/g, ' '],
        [/[\s\-–()]+/g, ' '],
        [/broad\s*/g, ''],
        [/br\s*/g, ''],
        // Full words - keep s and m
        [/nonets?/g, '9'],
        [/octets?/g, '8'],
        [/septets?/g, '7'],
        [/sextets?/g, '6'],
        [/quintets?/g, '5'],
        [/quartets?/g, '4'],
        [/triplets?/g, '3'],
        [/doublets?/g, '2'],
        [/singlets?/g, 's'],
        [/multiplets?/g, 'm'],
        // Abbreviations - keep s and m
        [/non(?!et)/g, '9'],
        [/oct(?!et)/g, '8'],
        [/sept(?!et)/g, '7'],
        [/sext(?!et)/g, '6'],
        [/quint(?!et)/g, '5'],
        [/q(?!u)/g, '4'],
        [/t(?!r|e)/g, '3'],
        [/d(?!o)/g, '2'],
        [/s(?!i)/g, 's'],
        [/m(?!u)/g, 'm'],
        [/b(?!r|o)/g, ''],
        [/\s+/g, ''],
    ];
    replacementMap.forEach(([pattern, replacement]) => {
        normalized = normalized.replace(pattern, replacement);
    });
    normalized = normalized.trim();
    // Validate s/m combinations
    if (/s/.test(normalized) || /m/.test(normalized)) {
        // Check for invalid s patterns
        if (/[sm][sm]/.test(normalized)) {
            throw new Error(`Invalid multiplicity combination: "${multiplicityText}" (multiple s / m)`);
        }
        if (/s\d|\ds/.test(normalized)) {
            throw new Error(`Invalid multiplicity combination: "${multiplicityText}" (s cannot combine with other multiplicities)`);
        }
        // Check for invalid m patterns
        if (/\dm/.test(normalized)) {
            throw new Error(`Invalid multiplicity combination: "${multiplicityText}" (m must be at the beginning)`);
        }
        // Single s or m is OK
        if (normalized === 's' || normalized === 'm') {
            return null;
        }
        // m + digits is OK (e.g., "m23" from "m(dt)")
        if (/^m\d+$/.test(normalized)) {
            const digits = normalized.match(/\d/g);
            if (digits && digits.length > 0) {
                return digits.map(d => parseInt(d, 10));
            }
        }
        // If we reach here, it's an invalid s/m combination
        throw new Error(`Invalid multiplicity combination: "${multiplicityText}"`);
    }
    if (normalized === '')
        return null;
    const digits = normalized.match(/\d/g);
    if (digits && digits.length > 0) {
        return digits.map(d => parseInt(d, 10));
    }
    throw new Error(`Unhandled multiplicity format: "${multiplicityText}"`);
}
/**
 * Check if J-values are optional for a given multiplicity
 * Returns true if multiplicity contains 'm', 'br', or 'broad' (e.g., "m(tt)", "br d", "bs")
 * @param {string} multiplicityText - Multiplicity string
 * @returns {boolean} - True if J-values are optional
 */
function isJValuesOptional(multiplicityText) {
    const clean = multiplicityText.toLowerCase().trim();
    // Check if contains m/br/broad
    const hasBroadOrMultiplet = /\b(m|multiplet|br|broad)\b|^b/.test(clean);
    if (!hasBroadOrMultiplet) {
        return false; // No m/br/broad → not optional
    }
    // If it's ONLY m/br/broad (no other multiplicity), return false
    // because J-values must be 0 (handled by multipletnumbers returning null)
    const jCounts = multipletnumbers(multiplicityText);
    if (jCounts === null) {
        return false; // Only m/br/broad → J-values must be 0, not optional
    }
    // Has both m/br/broad AND other multiplicity → optional
    return true;
}
// Validation functions using existing patterns - only J-value and multiplicity consistency
function validateNMRPeak(peak, index) {
    const errors = [];
    // Only validate J-value count against multiplicity
    if (peak.multiplicity) {
        try {
            const expectedJCounts = multipletnumbers(peak.multiplicity);
            if (expectedJCounts !== null) {
                const actualJCount = peak.jValues.filter(j => !isNaN(j) && j > 0).length;
                const expectedTotal = expectedJCounts.length;
                // Check if J-values are optional (e.g., "m(tt)", "br d")
                const isOptional = isJValuesOptional(peak.multiplicity);
                // If optional: allow 0 or expectedTotal J-values
                // If not optional: must have exactly expectedTotal J-values
                if (!isOptional && actualJCount !== expectedTotal) {
                    errors.push({
                        type: 'peak',
                        index,
                        field: 'jcount',
                        message: `Multiplicity "${peak.multiplicity}" expects ${expectedTotal} J-values, but found ${actualJCount}`
                    });
                }
                else if (isOptional && actualJCount !== 0 && actualJCount !== expectedTotal) {
                    errors.push({
                        type: 'peak',
                        index,
                        field: 'jcount',
                        message: `Multiplicity "${peak.multiplicity}" expects 0 or ${expectedTotal} J-values, but found ${actualJCount}`
                    });
                }
            }
        }
        catch (error) {
            // Invalid multiplicity format - ignore as it's not our concern
        }
    }
    return errors;
}
function validateNMRData(nmrData) {
    const errors = [];
    if (!nmrData || !nmrData.peaks) {
        return [];
    }
    // Validate each peak (only J-value and multiplicity consistency)
    nmrData.peaks.forEach((peak, index) => {
        const peakErrors = validateNMRPeak(peak, index);
        errors.push(...peakErrors);
    });
    return errors;
}
function validateRichTextContent(textContent, parseFunction) {
    try {
        const parsedData = parseFunction(textContent);
        return validateNMRData(parsedData);
    }
    catch (error) {
        // Parse errors are not validation errors - allow parsing to proceed
        return [];
    }
}

// NMR Formatter - Phase 2.1
// Converts structured NMRData objects into HTML-formatted academic text
// Helper function to format chemical shift values
function formatChemicalShift(shift, decimalPlaces = 2) {
    if (Array.isArray(shift)) {
        // Range format with en-dash
        return `${shift[0].toFixed(decimalPlaces)}–${shift[1].toFixed(decimalPlaces)}`;
    }
    return shift.toFixed(decimalPlaces);
}
// Helper function to format J-values with italics
function formatJValues(jValues, decimalPlaces = 2) {
    if (jValues.length === 0)
        return "";
    const jString = jValues.map(j => j.toFixed(decimalPlaces)).join(", ");
    return ` <I>J</I> = ${jString} Hz`;
}
function formatIntegration(integration, decimalPlaces = 1, nuclei = "1H") {
    // Handle empty/zero values
    if (integration === 0 || integration === "" || integration === null || integration === undefined) {
        return "";
    }
    // Extract the atom symbol from nuclei (e.g., "1H" -> "H", "13C" -> "C", "<sup>1</sup>H" -> "H")
    const nucleiText = nuclei.replace(/<[^>]+>/g, ""); // Remove HTML tags
    const atomSymbol = nucleiText.replace(/\d+/g, "") || "H"; // Remove all numbers
    // Handle string integration values
    if (typeof integration === "string") {
        const trimmed = integration.trim();
        if (trimmed === "")
            return "";
        // Try to parse as number for decimal formatting
        const parsed = parseFloat(trimmed);
        if (!isNaN(parsed)) {
            if (parsed === 0)
                return "";
            return `, ${parsed.toFixed(decimalPlaces)}${atomSymbol}`;
        }
        // If it's already formatted (contains atom symbols), return as is with comma
        if (/[A-Z]/.test(trimmed)) {
            return trimmed.startsWith(',') ? trimmed : `, ${trimmed}`;
        }
        // Otherwise, treat as raw integration string and add atom symbol
        return `, ${trimmed}${atomSymbol}`;
    }
    // Handle number integration values with precise decimal formatting
    if (integration === 0)
        return "";
    return `, ${integration.toFixed(decimalPlaces)}${atomSymbol}`;
}
// Helper function to format multiplicity
function formatMultiplicity(multiplicity) {
    if (!multiplicity)
        return "";
    return multiplicity;
}
// Helper function to format assignment
function formatAssignment(assignment) {
    if (!assignment || assignment.trim() === "")
        return "";
    return assignment.trim();
}
// Helper function to format a single peak
function formatSinglePeak(peak, shiftDecimalPlaces = 2, jValueDecimalPlaces = 1, integrationDecimalPlaces = 0, nuclei = "1H") {
    const shift = formatChemicalShift(peak.chemicalShift, shiftDecimalPlaces);
    const mult = formatMultiplicity(peak.multiplicity);
    const jValues = formatJValues(peak.jValues, jValueDecimalPlaces);
    const integration = formatIntegration(peak.integration, integrationDecimalPlaces, nuclei);
    const assignment = formatAssignment(peak.assignment);
    // Build the peak string: δ shift (multiplicity, J-values, integration, assignment)
    let peakStr = shift;
    if (mult || jValues || integration || assignment) {
        peakStr += " (";
        const parts = [];
        if (mult)
            parts.push(mult);
        if (jValues)
            parts.push(jValues.trim());
        if (integration)
            parts.push(integration.replace(", ", ""));
        if (assignment)
            parts.push(assignment);
        peakStr += parts.join(", ");
        peakStr += ")";
    }
    return peakStr;
}
// Helper function to format metadata section
function formatMetadata(metadata) {
    const parts = [];
    // Nuclei with superscript
    if (metadata.nuclei) {
        let nucleiFormatted = metadata.nuclei;
        // Apply superscript formatting for nuclei numbers
        nucleiFormatted = nucleiFormatted.replace(/^(\d+)/, "<sup>$1</sup>");
        parts.push(`${nucleiFormatted} NMR`);
    }
    // Solvent with subscript formatting
    if (metadata.solvent) {
        let solventFormatted = metadata.solvent;
        // Apply subscript formatting for numbers in solvent names
        solventFormatted = solventFormatted.replace(/(\d+)/g, "<sub>$1</sub>");
        parts.push(`(${solventFormatted}`);
    }
    // Frequency
    if (metadata.frequency && !isNaN(metadata.frequency)) {
        const freqPart = parts.length > 1 ? `, ${metadata.frequency} MHz)` : `(${metadata.frequency} MHz)`;
        if (parts.length > 1) {
            parts[parts.length - 1] += freqPart;
        }
        else {
            parts.push(freqPart);
        }
    }
    else if (metadata.solvent) {
        // Close the solvent parentheses if no frequency
        parts[parts.length - 1] += ")";
    }
    return parts.join(" ");
}
// Main formatting function
function generateFormattedText(data, shiftDecimalPlaces = 2, jValueDecimalPlaces = 1, integrationDecimalPlaces = 0) {
    var _a;
    if (!data || !data.peaks || data.peaks.length === 0) {
        return "";
    }
    Logger.debug('Formatting NMR data:', data);
    const result = [];
    // Add metadata section
    const metadataStr = formatMetadata(data.metadata);
    if (metadataStr) {
        result.push(metadataStr);
    }
    // Add delta symbol and peaks
    const nuclei = ((_a = data.metadata) === null || _a === void 0 ? void 0 : _a.nuclei) || "1H";
    const peakStrings = data.peaks.map(peak => formatSinglePeak(peak, shiftDecimalPlaces, jValueDecimalPlaces, integrationDecimalPlaces, nuclei));
    const peaksSection = "δ " + peakStrings.join(", ");
    result.push(peaksSection);
    // Join with space
    const formattedText = result.join(" ");
    Logger.debug('Generated formatted text:', formattedText);
    return formattedText;
}

// Export to window object for browser usage
window.Logger = Logger;
window.LogLevel = LogLevel;
window.NUCLEI_PRESETS = NUCLEI_PRESETS;
window.SOLVENT_PRESETS = SOLVENT_PRESETS;
window.NUCLEI_CONFIG = NUCLEI_CONFIG;
window.SOLVENT_CONFIG = SOLVENT_CONFIG;
window.getNucleiPatterns = getNucleiPatterns;
window.getSolventPatterns = getSolventPatterns;
window.extractNucleiFromText = extractNucleiFromText;
window.extractSolventFromText = extractSolventFromText;
window.isValidNucleiType = isValidNucleiType;
window.isValidSolventType = isValidSolventType;
window.Metadata = Metadata;
window.NMRPeak = NMRPeak;
window.NMRData = NMRData;
window.multipletnumbers = multipletnumbers;
window.formatChemicalShift = formatChemicalShift;
window.formatJValues = formatJValues;
window.formatIntegration = formatIntegration;
window.formatMultiplicity = formatMultiplicity;
window.formatAssignment = formatAssignment;
window.formatSinglePeak = formatSinglePeak;
window.formatMetadata = formatMetadata;
window.generateFormattedText = generateFormattedText;

console.log('NMR Formatter browser bundle loaded (auto-generated)');
