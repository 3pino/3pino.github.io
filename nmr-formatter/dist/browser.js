// Browser-compatible bundle for NMR Formatter
// Auto-generated by scripts/build-browser.js
// DO NOT EDIT THIS FILE MANUALLY - It will be overwritten on build

// ========== CORE & MODELS ==========
// Centralized logging utility
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["DEBUG"] = 0] = "DEBUG";
    LogLevel[LogLevel["INFO"] = 1] = "INFO";
    LogLevel[LogLevel["WARN"] = 2] = "WARN";
    LogLevel[LogLevel["ERROR"] = 3] = "ERROR";
    LogLevel[LogLevel["NONE"] = 4] = "NONE";
})(LogLevel || (LogLevel = {}));
class Logger {
    static setLogLevel(level) {
        this.logLevel = level;
    }
    static debug(message, ...args) {
        if (this.logLevel <= LogLevel.DEBUG) {
            console.log(`[DEBUG] ${message}`, ...args);
        }
    }
    static info(message, ...args) {
        if (this.logLevel <= LogLevel.INFO) {
            console.info(`[INFO] ${message}`, ...args);
        }
    }
    static warn(message, ...args) {
        if (this.logLevel <= LogLevel.WARN) {
            console.warn(`[WARN] ${message}`, ...args);
        }
    }
    static error(message, ...args) {
        if (this.logLevel <= LogLevel.ERROR) {
            console.error(`[ERROR] ${message}`, ...args);
        }
    }
}
Logger.logLevel = LogLevel.INFO;

// Configuration constants for nuclei and solvents
// Nuclei preset configurations
const NUCLEI_PRESETS = [
    { id: "1H", displayHTML: "<sup>1</sup>H", pattern: /(¹H|protone?|1H\s+NMR|NMR\s+1H)/i },
    { id: "2H", displayHTML: "<sup>2</sup>H", pattern: /(²H|deuterium|2H\s+NMR|NMR\s+2H)/i },
    { id: "13C", displayHTML: "<sup>13</sup>C", pattern: /(13C|¹³C|carbon)/i },
    { id: "14N", displayHTML: "<sup>14</sup>N", pattern: /(14N|¹⁴N)/i },
    { id: "15N", displayHTML: "<sup>15</sup>N", pattern: /(15N|¹⁵N)/i },
    { id: "19F", displayHTML: "<sup>19</sup>F", pattern: /(19F|¹⁹F)/i },
    { id: "23Na", displayHTML: "<sup>23</sup>Na", pattern: /(23Na|²³Na)/i },
    { id: "27Al", displayHTML: "<sup>27</sup>Al", pattern: /(27Al|²⁷Al)/i },
    { id: "29Si", displayHTML: "<sup>29</sup>Si", pattern: /(29Si|²⁹Si)/i },
    { id: "31P", displayHTML: "<sup>31</sup>P", pattern: /(31P|³¹P)/i }
];
// Solvent preset configurations
const SOLVENT_PRESETS = [
    { id: "D2O", displayHTML: "D<sub>2</sub>O", pattern: /([DH][2₂]O|water)/i },
    { id: "CD3OD", displayHTML: "CD<sub>3</sub>OD", pattern: /(C[DH][3₃]O[DH]|methanol)/i },
    { id: "CD3CN", displayHTML: "CD<sub>3</sub>CN", pattern: /(C[DH][3₃]CN|acetonitrile?)/i },
    { id: "(CD3)2SO", displayHTML: "DMSO–<I>d</I><sub>6</sub>", pattern: /(\(C[DH][3₃]\)[2₂]SO|Me[2₂]SO|DMSO)/i },
    { id: "(CD3)2CO", displayHTML: "acetone–<I>d</I><sub>6</sub>", pattern: /(\(C[DH][3₃]\)[2₂]CO|Me[2₂]CO|acetone?)/i },
    { id: "C6D6", displayHTML: "C<sub>6</sub>D<sub>6</sub>", pattern: /(C[6₆][DH][6₆]|benzene?)/i },
    { id: "toluene-d8", displayHTML: "toluene–<i>d</i><sub>8</sub>", pattern: /(toluene?)/i },
    { id: "CDCl3", displayHTML: "CDCl<sub>3</sub>", pattern: /(C[DH]Cl[3₃]|ch?loroform)/i },
    { id: "CD2Cl2", displayHTML: "CD<sub>2</sub>Cl<sub>2</sub>", pattern: /(C[DH][2₂]Cl[2₂]|dich?loromethane?)/i },
    { id: "THF-d8", displayHTML: "THF–<i>d</i><sub>8</sub>", pattern: /(THF|tetrahydrofuran)/i }
];
// Sort order preset configurations
const SORT_ORDER_PRESETS = [
    { id: "desc", displayHTML: "Descending", pattern: /desc/i },
    { id: "asc", displayHTML: "Ascending", pattern: /asc/i }
];
// Legacy Record-based configurations (for backward compatibility)
const NUCLEI_CONFIG = {
    "1H": /(¹H|protone?|1H\s+NMR|NMR\s+1H)/i,
    "2H": /(²H|deuterium|2H\s+NMR|NMR\s+2H)/i,
    "13C": /(13C|¹³C|carbon)/i,
    "14N": /(14N|¹⁴N)/i,
    "15N": /(15N|¹⁵N)/i,
    "19F": /(19F|¹⁹F)/i,
    "23Na": /(23Na|²³Na)/i,
    "27Al": /(27Al|²⁷Al)/i,
    "29Si": /(29Si|²⁹Si)/i,
    "31P": /(31P|³¹P)/i,
    "": null
};
const SOLVENT_CONFIG = {
    "D2O": /([DH][2₂]O|water)/i,
    "CD3OD": /(C[DH][3₃]O[DH]|methanol)/i,
    "CD3CN": /(C[DH][3₃]CN|acetonitrile?)/i,
    "(CD3)2SO": /(\(C[DH][3₃]\)[2₂]SO|Me[2₂]SO|DMSO)/i,
    "(CD3)2CO": /(\(C[DH][3₃]\)[2₂]CO|Me[2₂]CO|acetone?)/i,
    "C6D6": /(C[6₆][DH][6₆]|benzene?)/i,
    "toluene-d8": /(toluene?)/i,
    "CDCl3": /(C[DH]Cl[3₃]|ch?loroform)/i,
    "CD2Cl2": /(C[DH][2₂]Cl[2₂]|dich?loromethane?)/i,
    "THF-d8": /(THF|tetrahydrofuran)/i,
    "": null
};
// Utility functions for pattern access
function getNucleiPatterns() {
    const patterns = {};
    for (const [nuclei, pattern] of Object.entries(NUCLEI_CONFIG)) {
        if (pattern && nuclei !== "") {
            patterns[nuclei] = pattern;
        }
    }
    return patterns;
}
function getSolventPatterns() {
    const patterns = {};
    for (const [solvent, pattern] of Object.entries(SOLVENT_CONFIG)) {
        if (pattern && solvent !== "") {
            patterns[solvent] = pattern;
        }
    }
    return patterns;
}
// Type-safe extraction functions
function extractNucleiFromText(text) {
    for (const [nuclei, pattern] of Object.entries(NUCLEI_CONFIG)) {
        if (pattern && pattern.test(text)) {
            return nuclei;
        }
    }
    return "";
}
function extractSolventFromText(text) {
    for (const [solvent, pattern] of Object.entries(SOLVENT_CONFIG)) {
        if (pattern && pattern.test(text)) {
            return solvent;
        }
    }
    return "";
}
// Type safety validation functions
function isValidNucleiType(value) {
    return Object.keys(NUCLEI_CONFIG).includes(value);
}
function isValidSolventType(value) {
    return Object.keys(SOLVENT_CONFIG).includes(value);
}

// Metadata model for NMR data
class Metadata {
    constructor(nuclei = "", solvent = "", frequency = 0) {
        this.nuclei = nuclei;
        this.solvent = solvent;
        this.frequency = frequency;
    }
}
// Runtime validation functions
function validateNucleiType(nuclei) {
    if (isValidNucleiType(nuclei)) {
        return nuclei;
    }
    Logger.warn(`Invalid nuclei type: ${nuclei}. Falling back to empty string.`);
    return "";
}
function validateSolventType(solvent) {
    if (isValidSolventType(solvent)) {
        return solvent;
    }
    Logger.warn(`Invalid solvent type: ${solvent}. Falling back to empty string.`);
    return "";
}

// NMR Peak model
class NMRPeak {
    constructor(chemicalShift = 0, multiplicity = "", jValues = [], integration = 0, assignment = "") {
        this.chemicalShift = chemicalShift;
        this.multiplicity = multiplicity;
        this.jValues = jValues;
        this.integration = integration;
        this.assignment = assignment;
    }
    // Convenience getter/setter for compatibility with app.js
    get shift() {
        return typeof this.chemicalShift === 'number' ? this.chemicalShift : this.chemicalShift[0];
    }
    set shift(value) {
        this.chemicalShift = value;
    }
    /**
     * Get expected number of J-values based on multiplicity
     * Returns null for singlet(s), multiplet(m), or broad(br)
     * Returns array of expected J-value counts for compound multiplicities (e.g., dt -> [2,3])
     */
    static multipletnumbers(multiplicityText) {
        const clean = multiplicityText.toLowerCase().trim();
        let normalized = clean;
        const replacementMap = [
            [/\s+of\s+/g, ' '],
            [/[\s\-–()]+/g, ' '],
            [/broad\s*/g, ''],
            [/br\s*/g, ''],
            // Full words - keep s and m
            [/nonets?/g, '9'],
            [/octets?/g, '8'],
            [/septets?/g, '7'],
            [/sextets?/g, '6'],
            [/quintets?/g, '5'],
            [/quartets?/g, '4'],
            [/triplets?/g, '3'],
            [/doublets?/g, '2'],
            [/singlets?/g, 's'],
            [/multiplets?/g, 'm'],
            // Abbreviations - keep s and m
            [/non(?!et)/g, '9'],
            [/oct(?!et)/g, '8'],
            [/sept(?!et)/g, '7'],
            [/sext(?!et)/g, '6'],
            [/quint(?!et)/g, '5'],
            [/q(?!u)/g, '4'],
            [/t(?!r|e)/g, '3'],
            [/d(?!o)/g, '2'],
            [/s(?!i)/g, 's'],
            [/m(?!u)/g, 'm'],
            [/b(?!r|o)/g, ''],
            [/\s+/g, ''],
        ];
        replacementMap.forEach(([pattern, replacement]) => {
            normalized = normalized.replace(pattern, replacement);
        });
        normalized = normalized.trim();
        // Validate s/m combinations
        if (/s/.test(normalized) || /m/.test(normalized)) {
            // Check for invalid s patterns
            if (/[sm][sm]/.test(normalized)) {
                throw new Error(`Invalid multiplicity combination: "${multiplicityText}" (multiple s / m)`);
            }
            if (/s\d|\ds/.test(normalized)) {
                throw new Error(`Invalid multiplicity combination: "${multiplicityText}" (s cannot combine with other multiplicities)`);
            }
            // Check for invalid m patterns
            if (/\dm/.test(normalized)) {
                throw new Error(`Invalid multiplicity combination: "${multiplicityText}" (m must be at the beginning)`);
            }
            // Single s or m is OK
            if (normalized === 's' || normalized === 'm') {
                return null;
            }
            // m + digits is OK (e.g., "m23" from "m(dt)")
            if (/^m\d+$/.test(normalized)) {
                const digits = normalized.match(/\d/g);
                if (digits && digits.length > 0) {
                    return digits.map(d => parseInt(d, 10));
                }
            }
            // If we reach here, it's an invalid s/m combination
            throw new Error(`Invalid multiplicity combination: "${multiplicityText}"`);
        }
        if (normalized === '')
            return null;
        const digits = normalized.match(/\d/g);
        if (digits && digits.length > 0) {
            return digits.map(d => parseInt(d, 10));
        }
        throw new Error(`Unhandled multiplicity format: "${multiplicityText}"`);
    }
    /**
     * Check if J-values are optional for a given multiplicity
     * Returns true if multiplicity contains 'm', 'br', or 'broad' (e.g., "m(tt)", "br d", "bs")
     */
    static isJValuesOptional(multiplicityText) {
        const clean = multiplicityText.toLowerCase().trim();
        // Check if contains m/br/broad
        const hasBroadOrMultiplet = /\b(m|multiplet|br|broad)\b|^b/.test(clean);
        if (!hasBroadOrMultiplet) {
            return false; // No m/br/broad → not optional
        }
        // If it's ONLY m/br/broad (no other multiplicity), return false
        // because J-values must be 0 (handled by multipletnumbers returning null)
        const jCounts = NMRPeak.multipletnumbers(multiplicityText);
        if (jCounts === null) {
            return false; // Only m/br/broad → J-values must be 0, not optional
        }
        // Has both m/br/broad AND other multiplicity → optional
        return true;
    }
    /**
     * Validate this peak's J-value count against multiplicity
     */
    validate() {
        const errors = [];
        if (this.multiplicity) {
            try {
                const expectedJCounts = NMRPeak.multipletnumbers(this.multiplicity);
                if (expectedJCounts !== null) {
                    const actualJCount = this.jValues.filter((j) => !isNaN(j) && j > 0).length;
                    const expectedTotal = expectedJCounts.length;
                    // Check if J-values are optional (e.g., "m(tt)", "br d")
                    const isOptional = NMRPeak.isJValuesOptional(this.multiplicity);
                    // If optional: allow 0 or expectedTotal J-values
                    // If not optional: must have exactly expectedTotal J-values
                    if (!isOptional && actualJCount !== expectedTotal) {
                        errors.push({
                            type: 'peak',
                            index: 0,
                            field: 'jcount',
                            message: `Multiplicity "${this.multiplicity}" expects ${expectedTotal} J-values, but found ${actualJCount}`
                        });
                    }
                    else if (isOptional && actualJCount !== 0 && actualJCount !== expectedTotal) {
                        errors.push({
                            type: 'peak',
                            index: 0,
                            field: 'jcount',
                            message: `Multiplicity "${this.multiplicity}" expects 0 or ${expectedTotal} J-values, but found ${actualJCount}`
                        });
                    }
                }
            }
            catch (error) {
                // Invalid multiplicity format - ignore as it's not our concern
            }
        }
        return errors;
    }
}

// NMR Data model
class NMRData {
    constructor(peaks = [], metadata = new Metadata()) {
        this.peaks = peaks;
        this.metadata = metadata;
    }
    addPeak(peak) {
        this.peaks.push(peak);
    }
    removePeak(index) {
        if (index >= 0 && index < this.peaks.length) {
            this.peaks.splice(index, 1);
        }
    }
    updateMetadata(key, value) {
        this.metadata[key] = value;
    }
    /**
     * Validate all peaks in this NMR data
     */
    validate() {
        const errors = [];
        if (!this.peaks) {
            return [];
        }
        // Validate each peak (only J-value and multiplicity consistency)
        this.peaks.forEach((peak, index) => {
            const peakErrors = peak.validate();
            // Update index in errors
            peakErrors.forEach(error => {
                errors.push(Object.assign(Object.assign({}, error), { index }));
            });
        });
        return errors;
    }
}

/**
 * Utility functions for data parsing and conversion
 */
/**
 * Parse chemical shift string to number or range
 * Supports formats: "7.53", "7.53-7.50", "7.53–7.50"
 */
function parseChemicalShift(value) {
    if (!value || value.trim() === '')
        return null;
    const trimmed = value.trim();
    // Check for range format (supports both hyphen and en-dash)
    const rangeMatch = trimmed.match(/^([\d.]+)\s*[-–]\s*([\d.]+)$/);
    if (rangeMatch) {
        const num1 = parseFloat(rangeMatch[1]);
        const num2 = parseFloat(rangeMatch[2]);
        if (!isNaN(num1) && !isNaN(num2)) {
            return [num1, num2];
        }
    }
    // Single value
    const num = parseFloat(trimmed);
    if (!isNaN(num)) {
        return num;
    }
    return null;
}
/**
 * Convert multiplicity input to text format
 * Supports numeric shorthand: "1" -> "s", "23" -> "dt", etc.
 */
function convertMultiplicityToText(input) {
    if (!input || input.trim() === '')
        return '';
    const trimmed = input.trim();
    // Check if input is purely numeric
    if (/^\d+$/.test(trimmed)) {
        const digitMap = {
            '1': 's',
            '2': 'd',
            '3': 't',
            '4': 'q',
            '5': 'quint'
        };
        let result = '';
        for (const digit of trimmed) {
            if (digit >= '1' && digit <= '5') {
                result += digitMap[digit];
            }
        }
        return result;
    }
    return trimmed;
}
/**
 * Calculate required J-value columns based on multiplicity
 */
function calculateRequiredJColumns(multiplicity) {
    if (!multiplicity || multiplicity.trim() === '') {
        return 0;
    }
    try {
        const multipletnumbers = window.multipletnumbers;
        const jCounts = multipletnumbers(multiplicity);
        if (jCounts === null) {
            return 0;
        }
        return jCounts.length;
    }
    catch (_a) {
        return 0;
    }
}

/**
 * Utility functions for sorting NMR data
 */
/**
 * Sort peaks array by chemical shift value
 */
function sortPeaksByShift(peaks, order) {
    peaks.sort((a, b) => {
        const aValue = getShiftValue(a.chemicalShift);
        const bValue = getShiftValue(b.chemicalShift);
        if (order === 'asc') {
            return aValue - bValue;
        }
        else {
            return bValue - aValue;
        }
    });
}
/**
 * Get numeric value from chemical shift (average for ranges)
 */
function getShiftValue(shift) {
    if (Array.isArray(shift)) {
        return (shift[0] + shift[1]) / 2;
    }
    return shift;
}

/**
 * Utility functions for validating NMR data
 */
/**
 * Validate metadata fields
 * @returns true if there are errors
 */
function validateMetadata(metadata, validationState) {
    let hasErrors = false;
    if (!metadata.nuclei || metadata.nuclei.trim() === '') {
        validationState.setError('nuclei', 'Nuclei is required');
        hasErrors = true;
    }
    if (!metadata.solvent || metadata.solvent.trim() === '') {
        validationState.setError('solvent', 'Solvent is required');
        hasErrors = true;
    }
    if (!metadata.frequency || metadata.frequency === 0) {
        validationState.setError('frequency', 'Frequency is required');
        hasErrors = true;
    }
    return hasErrors;
}
/**
 * Validate a single table row
 * @returns true if there are errors
 */
function validateTableRow(row, is1HNMR, validationState) {
    let hasErrors = false;
    const rowId = row.id;
    // Validate chemical shift
    const shift = parseChemicalShift(row.shift);
    if (shift === null || row.shift.trim() === '') {
        validationState.setError(`shift-${rowId}`, 'Invalid chemical shift');
        hasErrors = true;
    }
    else {
        validationState.clearError(`shift-${rowId}`);
    }
    // Validate multiplicity (for 1H NMR)
    if (is1HNMR) {
        const multiplicity = convertMultiplicityToText(row.multiplicity);
        if (row.multiplicity.trim() === '') {
            validationState.setError(`mult-${rowId}`, 'Multiplicity is required for 1H NMR');
            hasErrors = true;
        }
        else {
            try {
                const multipletnumbers = window.multipletnumbers;
                multipletnumbers(multiplicity);
                validationState.clearError(`mult-${rowId}`);
            }
            catch (error) {
                validationState.setError(`mult-${rowId}`, 'Invalid multiplicity');
                hasErrors = true;
            }
        }
        // Validate integration (for 1H NMR)
        if (!row.integration || row.integration === 0) {
            validationState.setError(`int-${rowId}`, 'Integration is required for 1H NMR');
            hasErrors = true;
        }
        else {
            validationState.clearError(`int-${rowId}`);
        }
    }
    // Validate J-values
    const multiplicity = convertMultiplicityToText(row.multiplicity);
    const isJValuesOptional = window.isJValuesOptional;
    const isOptional = multiplicity && isJValuesOptional(multiplicity);
    const requiredJCount = calculateRequiredJColumns(multiplicity);
    const actualJCount = row.jValues.filter((j) => !isNaN(j) && j !== 0).length;
    if (isOptional) {
        // Optional: either all empty or all filled
        if (actualJCount > 0 && actualJCount < requiredJCount) {
            for (let i = 0; i < requiredJCount; i++) {
                if (!row.jValues[i] || row.jValues[i] === 0) {
                    validationState.setError(`j${i}-${rowId}`, 'All J-values must be filled');
                    hasErrors = true;
                }
                else {
                    validationState.clearError(`j${i}-${rowId}`);
                }
            }
        }
        else {
            // All filled or all empty - clear all errors
            for (let i = 0; i < requiredJCount; i++) {
                validationState.clearError(`j${i}-${rowId}`);
            }
        }
    }
    else {
        // Not optional: all must be filled
        for (let i = 0; i < requiredJCount; i++) {
            if (!row.jValues[i] || row.jValues[i] === 0) {
                validationState.setError(`j${i}-${rowId}`, 'J-value is required');
                hasErrors = true;
            }
            else {
                validationState.clearError(`j${i}-${rowId}`);
            }
        }
    }
    return hasErrors;
}
/**
 * Validate all table rows
 * @returns true if there are errors
 */
function validateTableRows(rows, is1HNMR, validationState) {
    let hasErrors = false;
    rows.forEach(row => {
        if (validateTableRow(row, is1HNMR, validationState)) {
            hasErrors = true;
        }
    });
    return hasErrors;
}

// NMR Formatter
// Converts structured NMRData objects into HTML-formatted academic text
// Helper function to format chemical shift values with significant figures
function formatChemicalShift(shift, significantFigures = 3) {
    if (Array.isArray(shift)) {
        // Range format with en-dash
        return `${formatSignificantFigures(shift[0], significantFigures)}–${formatSignificantFigures(shift[1], significantFigures)}`;
    }
    return formatSignificantFigures(shift, significantFigures);
}
// Helper function to format number with significant figures
function formatSignificantFigures(num, sigFigs) {
    if (num === 0)
        return '0';
    // Get the magnitude (order of 10)
    const magnitude = Math.floor(Math.log10(Math.abs(num)));
    // Calculate decimal places needed for the significant figures
    const decimalPlaces = Math.max(0, sigFigs - magnitude - 1);
    return num.toFixed(decimalPlaces);
}
// Helper function to format J-values with italics and significant figures
function formatJValues(jValues, significantFigures = 2) {
    if (jValues.length === 0)
        return "";
    const jString = jValues.map(j => formatSignificantFigures(j, significantFigures)).join(", ");
    return ` <I>J</I> = ${jString} Hz`;
}
function formatIntegration(integration, decimalPlaces = 1, nuclei = "1H") {
    // Handle empty/zero values
    if (integration === 0 || integration === "" || integration === null || integration === undefined) {
        return "";
    }
    // Extract the atom symbol from nuclei (e.g., "1H" -> "H", "13C" -> "C", "<sup>1</sup>H" -> "H")
    const nucleiText = nuclei.replace(/<[^>]+>/g, ""); // Remove HTML tags
    const atomSymbol = nucleiText.replace(/\d+/g, "") || "H"; // Remove all numbers
    // Handle string integration values
    if (typeof integration === "string") {
        const trimmed = integration.trim();
        if (trimmed === "")
            return "";
        // Try to parse as number for decimal formatting
        const parsed = parseFloat(trimmed);
        if (!isNaN(parsed)) {
            if (parsed === 0)
                return "";
            return `, ${parsed.toFixed(decimalPlaces)}${atomSymbol}`;
        }
        // If it's already formatted (contains atom symbols), return as is with comma
        if (/[A-Z]/.test(trimmed)) {
            return trimmed.startsWith(',') ? trimmed : `, ${trimmed}`;
        }
        // Otherwise, treat as raw integration string and add atom symbol
        return `, ${trimmed}${atomSymbol}`;
    }
    // Handle number integration values with precise decimal formatting
    if (integration === 0)
        return "";
    return `, ${integration.toFixed(decimalPlaces)}${atomSymbol}`;
}
// Helper function to format multiplicity
function formatMultiplicity(multiplicity) {
    if (!multiplicity)
        return "";
    return multiplicity;
}
// Helper function to format assignment
function formatAssignment(assignment) {
    if (!assignment || assignment.trim() === "")
        return "";
    return assignment.trim();
}
// Helper function to format a single peak
function formatSinglePeak(peak, shiftSigFigs = 3, jValueSigFigs = 2, integrationDecimalPlaces = 0, nuclei = "1H") {
    const shift = formatChemicalShift(peak.chemicalShift, shiftSigFigs);
    const mult = formatMultiplicity(peak.multiplicity);
    const jValues = formatJValues(peak.jValues, jValueSigFigs);
    const integration = formatIntegration(peak.integration, integrationDecimalPlaces, nuclei);
    const assignment = formatAssignment(peak.assignment);
    // Build the peak string: δ shift (multiplicity, J-values, integration, assignment)
    let peakStr = shift;
    if (mult || jValues || integration || assignment) {
        peakStr += " (";
        const parts = [];
        if (mult)
            parts.push(mult);
        if (jValues)
            parts.push(jValues.trim());
        if (integration)
            parts.push(integration.replace(", ", ""));
        if (assignment)
            parts.push(assignment);
        peakStr += parts.join(", ");
        peakStr += ")";
    }
    return peakStr;
}
// Helper function to format metadata section
function formatMetadata(metadata) {
    const parts = [];
    // Nuclei with superscript
    if (metadata.nuclei) {
        let nucleiFormatted = metadata.nuclei;
        // Apply superscript formatting for nuclei numbers
        nucleiFormatted = nucleiFormatted.replace(/^(\d+)/, "<sup>$1</sup>");
        parts.push(`${nucleiFormatted} NMR`);
    }
    // Solvent with subscript formatting
    if (metadata.solvent) {
        let solventFormatted = metadata.solvent;
        // Apply subscript formatting for numbers in solvent names
        solventFormatted = solventFormatted.replace(/(\d+)/g, "<sub>$1</sub>");
        parts.push(`(${solventFormatted}`);
    }
    // Frequency
    if (metadata.frequency && !isNaN(metadata.frequency)) {
        const freqPart = parts.length > 1 ? `, ${metadata.frequency} MHz)` : `(${metadata.frequency} MHz)`;
        if (parts.length > 1) {
            parts[parts.length - 1] += freqPart;
        }
        else {
            parts.push(freqPart);
        }
    }
    else if (metadata.solvent) {
        // Close the solvent parentheses if no frequency
        parts[parts.length - 1] += ")";
    }
    return parts.join(" ");
}
// Main formatting function
function generateFormattedText(data, shiftSigFigs = 3, jValueSigFigs = 2, integrationDecimalPlaces = 0) {
    var _a;
    if (!data || !data.peaks || data.peaks.length === 0) {
        return "";
    }
    Logger.debug('Formatting NMR data:', data);
    const result = [];
    // Add metadata section
    const metadataStr = formatMetadata(data.metadata);
    if (metadataStr) {
        result.push(metadataStr);
    }
    // Add delta symbol and peaks
    const nuclei = ((_a = data.metadata) === null || _a === void 0 ? void 0 : _a.nuclei) || "1H";
    const peakStrings = data.peaks.map(peak => formatSinglePeak(peak, shiftSigFigs, jValueSigFigs, integrationDecimalPlaces, nuclei));
    const peaksSection = "δ " + peakStrings.join(", ");
    result.push(peaksSection);
    // Join with space
    const formattedText = result.join(" ");
    Logger.debug('Generated formatted text:', formattedText);
    return formattedText;
}

// ========== STATE MANAGEMENT ==========
/**
 * Metadata State Management
 * Manages nuclei, solvent, frequency, precision, and sort order
 */
class MetadataState {
    constructor(initialData) {
        this.changeListeners = [];
        this.data = Object.assign({ nuclei: '<sup>1</sup>H', solvent: '', frequency: NaN, shiftPrecision: 3, jPrecision: 2, sortOrder: 'desc' }, initialData);
    }
    getData() {
        return Object.assign({}, this.data);
    }
    update(updates) {
        this.data = Object.assign(Object.assign({}, this.data), updates);
        this.notifyChange();
    }
    setNuclei(nuclei) {
        this.data.nuclei = nuclei;
        this.notifyChange();
    }
    setSolvent(solvent) {
        this.data.solvent = solvent;
        this.notifyChange();
    }
    setFrequency(frequency) {
        this.data.frequency = frequency;
        this.notifyChange();
    }
    setShiftPrecision(precision) {
        this.data.shiftPrecision = precision;
        this.notifyChange();
    }
    setJPrecision(precision) {
        this.data.jPrecision = precision;
        this.notifyChange();
    }
    setSortOrder(order) {
        this.data.sortOrder = order;
        this.notifyChange();
    }
    onChange(listener) {
        this.changeListeners.push(listener);
    }
    notifyChange() {
        this.changeListeners.forEach(listener => listener(this.getData()));
    }
}

/**
 * Table State Management
 * Manages NMR peak rows (shift, multiplicity, J-values, integration, assignment)
 */
class TableState {
    constructor() {
        this.rows = [];
        this.maxJColumns = 0;
        this.changeListeners = [];
        // Initialize with one empty row
        this.addRow();
    }
    getRows() {
        return this.rows.map(row => (Object.assign({}, row)));
    }
    getMaxJColumns() {
        return this.maxJColumns;
    }
    addRow(data) {
        const id = this.generateId();
        const newRow = Object.assign({ id, shift: '', multiplicity: '', jValues: [], integration: 0, assignment: '' }, data);
        this.rows.push(newRow);
        this.recalculateMaxJ();
        this.notifyChange();
        return id;
    }
    updateRow(id, updates) {
        const row = this.rows.find(r => r.id === id);
        if (row) {
            Object.assign(row, updates);
            this.recalculateMaxJ();
            this.notifyChange();
        }
    }
    removeRow(id) {
        this.rows = this.rows.filter(r => r.id !== id);
        // Ensure at least one row exists
        if (this.rows.length === 0) {
            this.addRow();
        }
        else {
            this.recalculateMaxJ();
            this.notifyChange();
        }
    }
    removeRows(ids) {
        this.rows = this.rows.filter(r => !ids.includes(r.id));
        // Ensure at least one row exists
        if (this.rows.length === 0) {
            this.addRow();
        }
        else {
            this.recalculateMaxJ();
            this.notifyChange();
        }
    }
    removeEmptyRows() {
        const emptyRowIds = this.rows
            .filter(row => {
            return row.shift.trim() === '' &&
                row.multiplicity.trim() === '' &&
                row.jValues.every(j => j === 0) &&
                row.integration === 0 &&
                row.assignment.trim() === '';
        })
            .map(row => row.id);
        if (emptyRowIds.length > 0) {
            this.removeRows(emptyRowIds);
        }
    }
    sortAllJValues() {
        this.rows.forEach(row => {
            if (row.jValues.length > 0) {
                row.jValues = [...row.jValues].sort((a, b) => b - a);
            }
        });
        this.notifyChange();
    }
    getRow(id) {
        const row = this.rows.find(r => r.id === id);
        return row ? Object.assign({}, row) : undefined;
    }
    setMaxJColumns(maxJ) {
        this.maxJColumns = maxJ;
        this.notifyChange();
    }
    recalculateMaxJ() {
        // This will be called by the UI layer after calculating required J columns
        // For now, we just store the value
    }
    onChange(listener) {
        this.changeListeners.push(listener);
    }
    notifyChange() {
        this.changeListeners.forEach(listener => listener(this.getRows(), this.maxJColumns));
    }
    generateId() {
        return `row-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    }
}

/**
 * Validation State Management
 * Tracks validation errors for metadata and table fields
 */
class ValidationState {
    constructor() {
        this.errors = new Map();
        this.changeListeners = [];
    }
    hasError(fieldId) {
        return this.errors.has(fieldId);
    }
    getError(fieldId) {
        return this.errors.get(fieldId);
    }
    getAllErrors() {
        return new Map(this.errors);
    }
    setError(fieldId, message) {
        this.errors.set(fieldId, message);
        this.notifyChange();
    }
    clearError(fieldId) {
        this.errors.delete(fieldId);
        this.notifyChange();
    }
    clearAllErrors() {
        this.errors.clear();
        this.notifyChange();
    }
    hasAnyErrors() {
        return this.errors.size > 0;
    }
    onChange(listener) {
        this.changeListeners.push(listener);
    }
    notifyChange() {
        this.changeListeners.forEach(listener => listener(this.getAllErrors()));
    }
}

/**
 * Application State Management
 * Central state container for the entire NMR Formatter application
 */
class AppState {
    constructor() {
        this.changeListeners = [];
        this.metadata = new MetadataState();
        this.table = new TableState();
        this.validation = new ValidationState();
        // Propagate child state changes to app-level listeners
        this.metadata.onChange(() => this.notifyChange());
        this.table.onChange(() => this.notifyChange());
        this.validation.onChange(() => this.notifyChange());
    }
    /**
     * Register a listener for any state change
     */
    onChange(listener) {
        this.changeListeners.push(listener);
    }
    /**
     * Clear all errors in validation state
     */
    clearAllErrors() {
        this.validation.clearAllErrors();
    }
    /**
     * Reset the entire application state
     */
    reset() {
        this.metadata = new MetadataState();
        this.table = new TableState();
        this.validation = new ValidationState();
        this.notifyChange();
    }
    notifyChange() {
        this.changeListeners.forEach(listener => listener());
    }
}

// ========== UI COMPONENTS ==========
/**
 * Metadata Form Component
 * Handles nuclei, solvent, frequency, precision, and sort order inputs
 */
class MetadataForm {
    constructor(metadataState, validationState, onNavigateNext, onSortOrderChange) {
        this.metadataState = metadataState;
        this.validationState = validationState;
        this.onSortOrderChange = onSortOrderChange;
        this.elements = {
            nuclei: document.getElementById('nuclei'),
            solvent: document.getElementById('solvent'),
            frequency: document.getElementById('frequency'),
            shiftPrecision: document.getElementById('shift-precision'),
            jPrecision: document.getElementById('j-precision'),
            sortOrder: document.getElementById('sort-order')
        };
        this.dropdowns = {
            nuclei: document.getElementById('nuclei-dropdown'),
            solvent: document.getElementById('solvent-dropdown')
        };
        this.initializeValues();
        this.initializeEventListeners(onNavigateNext);
        this.initializeDropdowns();
    }
    initializeValues() {
        const data = this.metadataState.getData();
        this.elements.nuclei.innerHTML = data.nuclei;
        this.elements.solvent.innerHTML = data.solvent;
        this.elements.frequency.textContent = isNaN(data.frequency) ? '' : data.frequency.toString();
        this.elements.shiftPrecision.textContent = '';
        this.elements.jPrecision.textContent = '';
        // Set sort order icon (default: Descending = down arrow)
        this.updateSortOrderIcon(data.sortOrder);
    }
    initializeEventListeners(onNavigateNext) {
        // Nuclei input
        this.setupContentEditableField(this.elements.nuclei, (value) => {
            this.metadataState.setNuclei(value);
        }, onNavigateNext);
        // Solvent input
        this.setupContentEditableField(this.elements.solvent, (value) => {
            this.metadataState.setSolvent(value);
        }, onNavigateNext);
        // Number fields
        this.setupNumberField(this.elements.frequency, (value) => {
            this.metadataState.setFrequency(value);
        }, null, null, onNavigateNext);
        this.setupNumberField(this.elements.shiftPrecision, (value) => {
            this.metadataState.setShiftPrecision(value);
        }, 1, 10, onNavigateNext);
        this.setupNumberField(this.elements.jPrecision, (value) => {
            this.metadataState.setJPrecision(value);
        }, 1, 10, onNavigateNext);
        // Sort order - toggle button
        this.setupSortOrderToggle(onNavigateNext);
        // Validation error display
        this.validationState.onChange((errors) => {
            Object.values(this.elements).forEach(el => {
                if (el instanceof HTMLElement) {
                    const fieldId = el.id;
                    if (errors.has(fieldId)) {
                        el.classList.add('error');
                    }
                    else {
                        el.classList.remove('error');
                    }
                }
            });
        });
    }
    setupContentEditableField(element, onChange, onNavigateNext) {
        // Paste filtering (only allow B, I, SUB, SUP tags)
        element.addEventListener('paste', (e) => {
            var _a, _b;
            e.preventDefault();
            const text = ((_a = e.clipboardData) === null || _a === void 0 ? void 0 : _a.getData('text/html')) || ((_b = e.clipboardData) === null || _b === void 0 ? void 0 : _b.getData('text/plain')) || '';
            const temp = document.createElement('div');
            temp.innerHTML = text;
            const filtered = this.filterHTMLTags(temp, ['B', 'I', 'SUB', 'SUP']);
            document.execCommand('insertHTML', false, filtered);
        });
        // Input handling
        element.addEventListener('input', () => {
            onChange(element.innerHTML);
            this.validationState.clearError(element.id);
        });
        // Enter, Tab, and Arrow key navigation
        element.addEventListener('keydown', (e) => {
            // Check if dropdown is active and has a highlighted item
            const fieldId = element.id;
            const dropdown = fieldId === 'nuclei' ? this.dropdowns.nuclei :
                fieldId === 'solvent' ? this.dropdowns.solvent : null;
            if (e.key === 'Enter') {
                // If dropdown is active and has a highlighted item, let it handle Enter
                if (dropdown && dropdown.classList.contains('active')) {
                    const highlightedItem = dropdown.querySelector('.dropdown-item.highlighted');
                    if (highlightedItem) {
                        // Don't navigate, let dropdown handler select the item
                        return;
                    }
                }
                // Otherwise, navigate to next field within the same group
                e.preventDefault();
                this.navigateWithinGroup(element, e.shiftKey);
                return;
            }
            if (e.key === 'Tab') {
                e.preventDefault();
                this.navigateWithinGroup(element, e.shiftKey);
                return;
            }
            // Smart left/right arrow navigation at boundaries
            if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
                const selection = window.getSelection();
                if (!selection || selection.rangeCount === 0)
                    return;
                const range = selection.getRangeAt(0);
                const text = element.textContent || '';
                // Check if there's a selection
                const hasSelection = !range.collapsed;
                if (!hasSelection) {
                    const cursorPosition = this.getCursorPosition(element);
                    if (e.key === 'ArrowRight' && cursorPosition >= text.length) {
                        // At right boundary, move to next field within group
                        e.preventDefault();
                        const fieldGroup = this.getFieldGroup(element);
                        const fieldIndex = fieldGroup.indexOf(element);
                        if (fieldIndex < fieldGroup.length - 1) {
                            const nextField = fieldGroup[fieldIndex + 1];
                            nextField.focus();
                            this.moveCursorToStart(nextField);
                        }
                        return;
                    }
                    else if (e.key === 'ArrowLeft' && cursorPosition === 0) {
                        // At left boundary, move to previous field within group
                        e.preventDefault();
                        const fieldGroup = this.getFieldGroup(element);
                        const fieldIndex = fieldGroup.indexOf(element);
                        if (fieldIndex > 0) {
                            const prevField = fieldGroup[fieldIndex - 1];
                            prevField.focus();
                            this.moveCursorToEnd(prevField);
                        }
                        return;
                    }
                }
            }
            // Keyboard shortcuts (Ctrl+B, Ctrl+I)
            if (e.ctrlKey || e.metaKey) {
                if (e.key === 'b' || e.key === 'B') {
                    e.preventDefault();
                    document.execCommand('bold');
                }
                else if (e.key === 'i' || e.key === 'I') {
                    e.preventDefault();
                    document.execCommand('italic');
                }
            }
        });
        // Ensure placeholder shows when field is empty on blur
        element.addEventListener('blur', () => {
            const cleaned = this.cleanupEmptyTags(element.innerHTML);
            if (cleaned === '' || cleaned === '<br>') {
                element.innerHTML = '';
            }
            else if (cleaned !== element.innerHTML) {
                element.innerHTML = cleaned;
            }
        });
    }
    setupNumberField(element, onChange, min, max, onNavigateNext) {
        // Enter, Tab, and Arrow key navigation
        element.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                // Prevent default behavior and stop propagation to avoid input event
                e.stopPropagation();
                this.navigateWithinGroup(element, e.shiftKey);
                return;
            }
            if (e.key === 'Tab') {
                e.preventDefault();
                this.navigateWithinGroup(element, e.shiftKey);
                return;
            }
            // Smart left/right arrow navigation at boundaries
            if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
                const selection = window.getSelection();
                if (!selection || selection.rangeCount === 0)
                    return;
                const range = selection.getRangeAt(0);
                const text = element.textContent || '';
                // Check if there's a selection
                const hasSelection = !range.collapsed;
                if (!hasSelection) {
                    const cursorPosition = this.getCursorPosition(element);
                    if (e.key === 'ArrowRight' && cursorPosition >= text.length) {
                        // At right boundary, move to next field within group
                        e.preventDefault();
                        const fieldGroup = this.getFieldGroup(element);
                        const fieldIndex = fieldGroup.indexOf(element);
                        if (fieldIndex < fieldGroup.length - 1) {
                            const nextField = fieldGroup[fieldIndex + 1];
                            nextField.focus();
                            this.moveCursorToStart(nextField);
                        }
                        return;
                    }
                    else if (e.key === 'ArrowLeft' && cursorPosition === 0) {
                        // At left boundary, move to previous field within group
                        e.preventDefault();
                        const fieldGroup = this.getFieldGroup(element);
                        const fieldIndex = fieldGroup.indexOf(element);
                        if (fieldIndex > 0) {
                            const prevField = fieldGroup[fieldIndex - 1];
                            prevField.focus();
                            this.moveCursorToEnd(prevField);
                        }
                        return;
                    }
                }
            }
        });
        // Input validation
        element.addEventListener('input', () => {
            const text = element.textContent || '';
            const cleanText = text.replace(/[^0-9]/g, '');
            if (text !== cleanText) {
                element.textContent = cleanText;
                this.moveCursorToEnd(element);
            }
            if (cleanText !== '') {
                const num = parseInt(cleanText);
                onChange(num);
                if ((min !== null && num < min) || (max !== null && num > max)) {
                    element.classList.add('error');
                }
                else {
                    element.classList.remove('error');
                }
            }
            else {
                element.classList.remove('error');
            }
        });
        // Paste filtering
        element.addEventListener('paste', (e) => {
            var _a;
            e.preventDefault();
            const text = ((_a = e.clipboardData) === null || _a === void 0 ? void 0 : _a.getData('text/plain')) || '';
            const cleanText = text.replace(/[^0-9]/g, '');
            document.execCommand('insertText', false, cleanText);
        });
        // Clear error on focus
        element.addEventListener('focus', () => {
            this.validationState.clearError(element.id);
        });
        // Ensure placeholder shows when field is empty on blur
        element.addEventListener('blur', () => {
            const text = element.textContent || '';
            if (text.trim() === '') {
                element.textContent = '';
            }
        });
    }
    initializeDropdowns() {
        this.setupDropdown('nuclei', window.NUCLEI_PRESETS || []);
        this.setupDropdown('solvent', window.SOLVENT_PRESETS || []);
    }
    setupDropdown(field, presets) {
        const input = this.elements[field];
        const dropdown = this.dropdowns[field];
        if (!input || !dropdown)
            return;
        // Prevent dropdown from receiving focus
        dropdown.setAttribute('tabindex', '-1');
        // Populate dropdown
        dropdown.innerHTML = '';
        presets.forEach(preset => {
            const item = document.createElement('div');
            item.className = 'dropdown-item';
            item.setAttribute('data-value', preset.displayHTML);
            item.innerHTML = preset.displayHTML;
            dropdown.appendChild(item);
        });
        // Track selected index for keyboard navigation
        let selectedIndex = -1;
        // Show/hide dropdown
        input.addEventListener('focus', () => {
            dropdown.classList.add('active');
            selectedIndex = -1; // Reset selection on focus
        });
        input.addEventListener('blur', () => {
            setTimeout(() => {
                dropdown.classList.remove('active');
                // Clear highlight
                dropdown.querySelectorAll('.dropdown-item').forEach(item => {
                    item.classList.remove('highlighted');
                });
            }, 200);
        });
        // Keyboard navigation for dropdown
        input.addEventListener('keydown', (e) => {
            if (!dropdown.classList.contains('active'))
                return;
            const items = Array.from(dropdown.querySelectorAll('.dropdown-item'));
            if (items.length === 0)
                return;
            if (e.key === 'ArrowDown') {
                e.preventDefault();
                selectedIndex = Math.min(selectedIndex + 1, items.length - 1);
                this.highlightDropdownItem(items, selectedIndex);
            }
            else if (e.key === 'ArrowUp') {
                e.preventDefault();
                selectedIndex = Math.max(selectedIndex - 1, -1);
                this.highlightDropdownItem(items, selectedIndex);
            }
            else if (e.key === 'Enter' && selectedIndex >= 0) {
                e.preventDefault();
                const value = items[selectedIndex].getAttribute('data-value') || '';
                input.innerHTML = value;
                this.handleDropdownSelection(field, value);
                dropdown.classList.remove('active');
                // Clear highlight
                this.highlightDropdownItem(items, -1);
                selectedIndex = -1;
            }
        });
        // Handle selection
        dropdown.querySelectorAll('.dropdown-item').forEach(item => {
            item.addEventListener('mousedown', (e) => {
                e.preventDefault();
                const value = item.getAttribute('data-value') || '';
                input.innerHTML = value;
                this.handleDropdownSelection(field, value);
                dropdown.classList.remove('active');
            });
        });
    }
    /**
     * Highlight the selected dropdown item
     */
    highlightDropdownItem(items, index) {
        items.forEach((item, i) => {
            if (i === index) {
                item.classList.add('highlighted');
                item.scrollIntoView({ block: 'nearest' });
            }
            else {
                item.classList.remove('highlighted');
            }
        });
    }
    /**
     * Handle dropdown selection for different fields
     */
    handleDropdownSelection(field, value) {
        if (field === 'nuclei') {
            this.metadataState.setNuclei(value);
        }
        else if (field === 'solvent') {
            this.metadataState.setSolvent(value);
        }
    }
    /**
     * Get cursor position in contenteditable element
     */
    getCursorPosition(element) {
        const selection = window.getSelection();
        if (!selection || selection.rangeCount === 0)
            return 0;
        const range = selection.getRangeAt(0);
        const preCaretRange = range.cloneRange();
        preCaretRange.selectNodeContents(element);
        preCaretRange.setEnd(range.endContainer, range.endOffset);
        return preCaretRange.toString().length;
    }
    /**
     * Move cursor to start of element
     */
    moveCursorToStart(element) {
        const range = document.createRange();
        const sel = window.getSelection();
        if (element.childNodes.length > 0) {
            range.setStart(element.childNodes[0], 0);
            range.collapse(true);
            sel === null || sel === void 0 ? void 0 : sel.removeAllRanges();
            sel === null || sel === void 0 ? void 0 : sel.addRange(range);
        }
    }
    /**
     * Setup sort order toggle button
     */
    setupSortOrderToggle(onNavigateNext) {
        const button = this.elements.sortOrder;
        // Click handler - toggle between asc and desc
        button.addEventListener('click', (e) => {
            var _a;
            e.preventDefault();
            const currentOrder = this.metadataState.getData().sortOrder;
            const newOrder = currentOrder === 'desc' ? 'asc' : 'desc';
            this.metadataState.setSortOrder(newOrder);
            this.updateSortOrderIcon(newOrder);
            // Trigger formatted text regeneration
            (_a = this.onSortOrderChange) === null || _a === void 0 ? void 0 : _a.call(this);
        });
        // Keyboard navigation
        button.addEventListener('keydown', (e) => {
            var _a;
            if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                const currentOrder = this.metadataState.getData().sortOrder;
                const newOrder = currentOrder === 'desc' ? 'asc' : 'desc';
                this.metadataState.setSortOrder(newOrder);
                this.updateSortOrderIcon(newOrder);
                // Trigger formatted text regeneration
                (_a = this.onSortOrderChange) === null || _a === void 0 ? void 0 : _a.call(this);
                return;
            }
            if (e.key === 'Tab') {
                e.preventDefault();
                this.navigateWithinGroup(button, e.shiftKey);
                return;
            }
            // Arrow key navigation within field group
            if (e.key === 'ArrowLeft') {
                e.preventDefault();
                const fieldGroup = this.getFieldGroup(button);
                const fieldIndex = fieldGroup.indexOf(button);
                if (fieldIndex > 0) {
                    const prevField = fieldGroup[fieldIndex - 1];
                    prevField.focus();
                    this.moveCursorToEnd(prevField);
                }
                return;
            }
            if (e.key === 'ArrowRight') {
                e.preventDefault();
                const fieldGroup = this.getFieldGroup(button);
                const fieldIndex = fieldGroup.indexOf(button);
                if (fieldIndex < fieldGroup.length - 1) {
                    const nextField = fieldGroup[fieldIndex + 1];
                    nextField.focus();
                    this.moveCursorToStart(nextField);
                }
                return;
            }
        });
    }
    /**
     * Update sort order icon based on current state
     */
    updateSortOrderIcon(sortOrder) {
        const button = this.elements.sortOrder;
        const icon = button.querySelector('i');
        if (icon) {
            if (sortOrder === 'desc') {
                // Descending = down arrow
                icon.className = 'fi fi-rr-down';
                button.setAttribute('title', 'Sort: Descending (High → Low)');
            }
            else {
                // Ascending = up arrow
                icon.className = 'fi fi-rr-up';
                button.setAttribute('title', 'Sort: Ascending (Low → High)');
            }
        }
    }
    filterHTMLTags(element, allowedTags) {
        let result = '';
        element.childNodes.forEach(node => {
            if (node.nodeType === Node.TEXT_NODE) {
                result += node.textContent;
            }
            else if (node.nodeType === Node.ELEMENT_NODE) {
                const tagName = node.tagName.toUpperCase();
                if (allowedTags.includes(tagName)) {
                    result += `<${tagName.toLowerCase()}>${this.filterHTMLTags(node, allowedTags)}</${tagName.toLowerCase()}>`;
                }
                else {
                    result += this.filterHTMLTags(node, allowedTags);
                }
            }
        });
        return result;
    }
    moveCursorToEnd(element) {
        var _a;
        const range = document.createRange();
        const sel = window.getSelection();
        if (element.childNodes.length > 0) {
            // Find the last node (could be text or element)
            const lastNode = element.childNodes[element.childNodes.length - 1];
            if (lastNode.nodeType === Node.TEXT_NODE) {
                // Text node: set cursor at end
                const length = ((_a = lastNode.textContent) === null || _a === void 0 ? void 0 : _a.length) || 0;
                range.setStart(lastNode, length);
            }
            else if (lastNode.nodeType === Node.ELEMENT_NODE) {
                // Element node: set cursor after it
                range.setStartAfter(lastNode);
            }
            else {
                // Fallback: set after last node
                range.setStartAfter(lastNode);
            }
            range.collapse(true);
            sel === null || sel === void 0 ? void 0 : sel.removeAllRanges();
            sel === null || sel === void 0 ? void 0 : sel.addRange(range);
        }
    }
    /**
     * Remove empty HTML tags (tags with no text content)
     * @param html The HTML string to clean
     * @returns Cleaned HTML string
     */
    cleanupEmptyTags(html) {
        const temp = document.createElement('div');
        temp.innerHTML = html.trim();
        // Recursively remove empty elements
        const removeEmptyElements = (element) => {
            const children = Array.from(element.children);
            children.forEach(child => {
                var _a;
                removeEmptyElements(child);
                // Remove if element has no text content and no non-empty children
                const textContent = ((_a = child.textContent) === null || _a === void 0 ? void 0 : _a.trim()) || '';
                if (textContent === '' && child.children.length === 0) {
                    child.remove();
                }
            });
        };
        removeEmptyElements(temp);
        return temp.innerHTML;
    }
    getFieldOrder() {
        // Legacy method - returns all fields
        return [
            this.elements.nuclei,
            this.elements.solvent,
            this.elements.frequency,
            this.elements.shiftPrecision,
            this.elements.jPrecision,
            this.elements.sortOrder
        ];
    }
    /**
     * Get metadata fields order (group 1: nuclei → solvent → frequency)
     */
    getMetadataFieldOrder() {
        return [
            this.elements.nuclei,
            this.elements.solvent,
            this.elements.frequency
        ];
    }
    /**
     * Get settings fields order (group 2: shift-precision → j-precision → sort-order)
     */
    getSettingsFieldOrder() {
        return [
            this.elements.shiftPrecision,
            this.elements.jPrecision,
            this.elements.sortOrder
        ];
    }
    /**
     * Get the appropriate field group for the given element
     */
    getFieldGroup(element) {
        const metadataFields = this.getMetadataFieldOrder();
        const settingsFields = this.getSettingsFieldOrder();
        if (metadataFields.includes(element)) {
            return metadataFields;
        }
        else if (settingsFields.includes(element)) {
            return settingsFields;
        }
        return [];
    }
    /**
     * Navigate to next/previous field within the same group
     */
    /**
     * Navigate to next/previous field within the same group
     */
    navigateWithinGroup(element, reverse) {
        const fieldGroup = this.getFieldGroup(element);
        if (fieldGroup.length === 0)
            return;
        const currentIndex = fieldGroup.indexOf(element);
        if (currentIndex === -1)
            return;
        let targetIndex;
        if (reverse) {
            targetIndex = currentIndex - 1;
            // Don't wrap - stay at first field
            if (targetIndex < 0)
                return;
        }
        else {
            targetIndex = currentIndex + 1;
            // Don't wrap - stay at last field
            if (targetIndex >= fieldGroup.length)
                return;
        }
        const targetField = fieldGroup[targetIndex];
        targetField.focus();
        // Select all text in the target field
        this.selectAllText(targetField);
    }
    /**
     * Select all text in a contenteditable element
     */
    selectAllText(element) {
        const range = document.createRange();
        const sel = window.getSelection();
        range.selectNodeContents(element);
        sel === null || sel === void 0 ? void 0 : sel.removeAllRanges();
        sel === null || sel === void 0 ? void 0 : sel.addRange(range);
    }
}

/**
 * NMR Table Component
 * Manages the table UI for NMR peak data
 */
class NMRTable {
    constructor(tableState, validationState, onMultiplicityChange, onNavigateToMetadata) {
        this.maxJColumns = 0;
        // Row ID to TR element mapping
        this.rowElements = new Map();
        this.tableState = tableState;
        this.validationState = validationState;
        this.tableBody = document.getElementById('nmr-table-body');
        this.tableElement = document.getElementById('nmr-table');
        this.keyboardNav = new KeyboardNav();
        this.initializeEventListeners(onMultiplicityChange, onNavigateToMetadata);
        this.renderTable();
        // Listen to state changes
        this.tableState.onChange((rows, maxJ) => {
            // Only re-render if rows were added/removed
            // For updates to existing rows, the DOM is already updated via event handlers
            const currentRowCount = this.rowElements.size;
            const newRowCount = rows.length;
            if (currentRowCount !== newRowCount) {
                this.maxJColumns = maxJ;
                this.renderTable();
            }
        });
        // Listen to validation state changes
        this.validationState.onChange((errors) => {
            this.rowElements.forEach((tr, rowId) => {
                // Shift input
                const shiftInput = tr.querySelector('.shift-input');
                if (shiftInput) {
                    if (errors.has(`shift-${rowId}`)) {
                        shiftInput.classList.add('error');
                    }
                    else {
                        shiftInput.classList.remove('error');
                    }
                }
                // Multiplicity input
                const multInput = tr.querySelector('.mult-input');
                if (multInput) {
                    if (errors.has(`mult-${rowId}`)) {
                        multInput.classList.add('error');
                    }
                    else {
                        multInput.classList.remove('error');
                    }
                }
                // Integration input
                const intInput = tr.querySelector('.int-input');
                if (intInput) {
                    if (errors.has(`int-${rowId}`)) {
                        intInput.classList.add('error');
                    }
                    else {
                        intInput.classList.remove('error');
                    }
                }
                // J-value inputs
                const jInputs = tr.querySelectorAll('.j-input');
                jInputs.forEach((jInput, index) => {
                    if (errors.has(`j${index}-${rowId}`)) {
                        jInput.classList.add('error');
                    }
                    else {
                        jInput.classList.remove('error');
                    }
                });
                // Assignment input
                const assignmentInput = tr.querySelector('.assignment-input');
                if (assignmentInput) {
                    if (errors.has(`assignment-${rowId}`)) {
                        assignmentInput.classList.add('error');
                    }
                    else {
                        assignmentInput.classList.remove('error');
                    }
                }
            });
        });
    }
    initializeEventListeners(onMultiplicityChange, onNavigateToMetadata) {
        // Add row footer cell
        this.renderAddRowFooter();
    }
    renderAddRowFooter() {
        // Remove existing add-row if present
        const existingAddRow = this.tableBody.querySelector('.add-row-footer');
        if (existingAddRow) {
            existingAddRow.remove();
        }
        const addRow = document.createElement('tr');
        addRow.className = 'add-row-footer';
        // Empty delete cell
        const deleteCell = document.createElement('td');
        deleteCell.className = 'delete-cell';
        addRow.appendChild(deleteCell);
        // Calculate remaining columns (shift + mult + J columns + integration + assignment)
        const remainingColumns = 4 + this.maxJColumns;
        const addCell = document.createElement('td');
        addCell.className = 'add-row-cell';
        addCell.colSpan = remainingColumns;
        addCell.innerHTML = '<button class="add-row-btn" title="Add new row">+</button>';
        const addButton = addCell.querySelector('.add-row-btn');
        addButton.tabIndex = -1; // Exclude from tab order
        addButton.addEventListener('click', () => {
            const newId = this.tableState.addRow();
            requestAnimationFrame(() => {
                const newRow = this.rowElements.get(newId);
                if (newRow) {
                    const firstInput = newRow.querySelector('.shift-input');
                    firstInput === null || firstInput === void 0 ? void 0 : firstInput.focus();
                }
            });
        });
        addRow.appendChild(addCell);
        this.tableBody.appendChild(addRow);
    }
    renderTable() {
        const rows = this.tableState.getRows();
        // Clear existing rows
        this.tableBody.innerHTML = '';
        this.rowElements.clear();
        // Render each row
        rows.forEach(rowData => {
            const tr = this.createTableRow(rowData);
            this.rowElements.set(rowData.id, tr);
            this.tableBody.appendChild(tr);
        });
        // Update J column visibility to preserve table state
        this.updateJColumnVisibility();
        // Re-render footer to update column span
        this.renderAddRowFooter();
    }
    createTableRow(rowData) {
        const row = document.createElement('tr');
        row.setAttribute('data-row-id', rowData.id);
        // Delete button cell
        const deleteCell = document.createElement('td');
        deleteCell.className = 'delete-cell';
        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'delete-row-btn';
        deleteBtn.textContent = '×';
        deleteBtn.title = 'Delete this row';
        deleteBtn.tabIndex = -1;
        deleteCell.appendChild(deleteBtn);
        this.setupDeleteButton(deleteBtn, rowData.id);
        row.appendChild(deleteCell);
        // Chemical shift cell
        const shiftCell = document.createElement('td');
        const shiftInput = document.createElement('input');
        shiftInput.type = 'text';
        shiftInput.className = 'shift-input';
        shiftInput.placeholder = '0.00 or 7.53–7.50';
        shiftInput.value = rowData.shift;
        shiftCell.appendChild(shiftInput);
        this.setupShiftInput(shiftInput, rowData.id, row);
        row.appendChild(shiftCell);
        // Multiplicity cell
        const multCell = document.createElement('td');
        const multInput = document.createElement('input');
        multInput.type = 'text';
        multInput.className = 'mult-input';
        multInput.placeholder = 's, d, t...';
        multInput.value = rowData.multiplicity;
        multCell.appendChild(multInput);
        this.setupMultiplicityInput(multInput, rowData.id, row);
        row.appendChild(multCell);
        // J-value cells (10 max, dynamically shown/hidden)
        const MAX_J_CELLS = 10;
        for (let i = 0; i < MAX_J_CELLS; i++) {
            const jCell = document.createElement('td');
            jCell.className = 'j-input-cell';
            const jInput = document.createElement('input');
            jInput.type = 'text';
            jInput.className = 'j-input';
            jInput.setAttribute('data-j-index', i.toString());
            jInput.setAttribute('inputmode', 'decimal');
            jInput.placeholder = '0.0';
            if (i < rowData.jValues.length) {
                jInput.value = rowData.jValues[i].toString();
            }
            jCell.appendChild(jInput);
            this.setupJInput(jInput, rowData.id, i, row);
            // Initially hide all J cells
            jCell.style.display = 'none';
            row.appendChild(jCell);
        }
        // Integration cell
        const intCell = document.createElement('td');
        intCell.className = 'int-cell';
        const intInput = document.createElement('input');
        intInput.type = 'text';
        intInput.className = 'int-input';
        intInput.setAttribute('inputmode', 'decimal');
        intInput.placeholder = '1';
        if (rowData.integration) {
            intInput.value = rowData.integration.toString();
        }
        intCell.appendChild(intInput);
        this.setupIntegrationInput(intInput, rowData.id, row);
        row.appendChild(intCell);
        // Assignment cell
        const assignmentCell = document.createElement('td');
        assignmentCell.className = 'assignment-cell';
        const assignmentInput = document.createElement('div');
        assignmentInput.className = 'assignment-input';
        assignmentInput.setAttribute('contenteditable', 'true');
        assignmentInput.setAttribute('data-placeholder', 'e.g., H-8');
        assignmentInput.innerHTML = rowData.assignment;
        assignmentCell.appendChild(assignmentInput);
        this.setupAssignmentInput(assignmentInput, rowData.id, row);
        row.appendChild(assignmentCell);
        return row;
    }
    setupShiftInput(input, rowId, row) {
        input.addEventListener('input', () => {
            this.tableState.updateRow(rowId, { shift: input.value });
            // Clear error on input (real-time clearing, no new errors shown)
            this.validationState.clearError(`shift-${rowId}`);
        });
        input.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                this.focusNextTableCell(input, row, e.shiftKey);
            }
            else if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                // Check if ArrowDown at last row
                if (e.key === 'ArrowDown') {
                    const isLastRow = !row.nextElementSibling || row.nextElementSibling.classList.contains('add-row-footer');
                    if (isLastRow) {
                        e.preventDefault();
                        const newId = this.tableState.addRow();
                        requestAnimationFrame(() => {
                            const newRow = this.rowElements.get(newId);
                            if (newRow) {
                                const targetInput = newRow.querySelector('.shift-input');
                                targetInput === null || targetInput === void 0 ? void 0 : targetInput.focus();
                            }
                        });
                        return;
                    }
                }
                this.keyboardNav.handleCellNavigation(e, input, row, (direction) => {
                    this.keyboardNav.navigateToCell(row, input, direction);
                });
            }
        });
    }
    setupMultiplicityInput(input, rowId, row) {
        input.addEventListener('input', () => {
            this.tableState.updateRow(rowId, { multiplicity: input.value });
            // Clear error on input (real-time clearing, no new errors shown)
            this.validationState.clearError(`mult-${rowId}`);
            // Recalculate J columns when multiplicity changes
            this.updateJColumnVisibility();
        });
        input.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                this.focusNextTableCell(input, row, e.shiftKey);
            }
            else if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                // Check if ArrowDown at last row
                if (e.key === 'ArrowDown') {
                    const isLastRow = !row.nextElementSibling || row.nextElementSibling.classList.contains('add-row-footer');
                    if (isLastRow) {
                        e.preventDefault();
                        const newId = this.tableState.addRow();
                        requestAnimationFrame(() => {
                            const newRow = this.rowElements.get(newId);
                            if (newRow) {
                                const targetInput = newRow.querySelector('.mult-input');
                                targetInput === null || targetInput === void 0 ? void 0 : targetInput.focus();
                            }
                        });
                        return;
                    }
                }
                this.keyboardNav.handleCellNavigation(e, input, row, (direction) => {
                    this.keyboardNav.navigateToCell(row, input, direction);
                });
            }
        });
    }
    setupJInput(input, rowId, index, row) {
        input.addEventListener('input', () => {
            // Filter to allow only numbers and ONE decimal point
            let filtered = input.value.replace(/[^0-9.]/g, '');
            // Allow only one decimal point
            const parts = filtered.split('.');
            if (parts.length > 2) {
                filtered = parts[0] + '.' + parts.slice(1).join('');
            }
            if (filtered !== input.value) {
                input.value = filtered;
            }
            const rowData = this.tableState.getRow(rowId);
            if (rowData) {
                const jValues = [...rowData.jValues];
                const value = parseFloat(input.value);
                if (!isNaN(value)) {
                    jValues[index] = Math.abs(value); // Auto-correct to absolute
                    // Don't sort during input - only update state
                    this.tableState.updateRow(rowId, { jValues });
                }
            }
            // Clear error on input (real-time clearing, no new errors shown)
            this.validationState.clearError(`j${index}-${rowId}`);
        });
        // J-value sorting removed - will be handled when Generate Text is clicked
        input.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                this.focusNextTableCell(input, row, e.shiftKey);
            }
            else if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                // Check if ArrowDown at last row
                if (e.key === 'ArrowDown') {
                    const isLastRow = !row.nextElementSibling || row.nextElementSibling.classList.contains('add-row-footer');
                    if (isLastRow) {
                        e.preventDefault();
                        const newId = this.tableState.addRow();
                        requestAnimationFrame(() => {
                            const newRow = this.rowElements.get(newId);
                            if (newRow) {
                                const cellIndex = Array.from(row.children).indexOf(input.closest('td'));
                                const targetCell = newRow.children[cellIndex];
                                const targetInput = targetCell === null || targetCell === void 0 ? void 0 : targetCell.querySelector('input');
                                targetInput === null || targetInput === void 0 ? void 0 : targetInput.focus();
                            }
                        });
                        return;
                    }
                }
                this.keyboardNav.handleCellNavigation(e, input, row, (direction) => {
                    this.keyboardNav.navigateToCell(row, input, direction);
                });
            }
        });
    }
    setupIntegrationInput(input, rowId, row) {
        input.addEventListener('input', () => {
            // Filter to allow only numbers and ONE decimal point
            let filtered = input.value.replace(/[^0-9.]/g, '');
            // Allow only one decimal point
            const parts = filtered.split('.');
            if (parts.length > 2) {
                filtered = parts[0] + '.' + parts.slice(1).join('');
            }
            if (filtered !== input.value) {
                input.value = filtered;
            }
            const value = parseFloat(input.value);
            this.tableState.updateRow(rowId, { integration: isNaN(value) ? 0 : value });
            // Clear error on input (real-time clearing, no new errors shown)
            this.validationState.clearError(`int-${rowId}`);
        });
        input.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                this.focusNextTableCell(input, row, e.shiftKey);
            }
            else if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                // Check if ArrowDown at last row
                if (e.key === 'ArrowDown') {
                    const isLastRow = !row.nextElementSibling || row.nextElementSibling.classList.contains('add-row-footer');
                    if (isLastRow) {
                        e.preventDefault();
                        const newId = this.tableState.addRow();
                        requestAnimationFrame(() => {
                            const newRow = this.rowElements.get(newId);
                            if (newRow) {
                                const targetInput = newRow.querySelector('.int-input');
                                targetInput === null || targetInput === void 0 ? void 0 : targetInput.focus();
                            }
                        });
                        return;
                    }
                }
                this.keyboardNav.handleCellNavigation(e, input, row, (direction) => {
                    this.keyboardNav.navigateToCell(row, input, direction);
                });
            }
        });
    }
    setupAssignmentInput(input, rowId, row) {
        // Paste filtering
        input.addEventListener('paste', (e) => {
            e.preventDefault();
            const clipboardData = e.clipboardData;
            const text = (clipboardData === null || clipboardData === void 0 ? void 0 : clipboardData.getData('text/html')) || (clipboardData === null || clipboardData === void 0 ? void 0 : clipboardData.getData('text/plain')) || '';
            const temp = document.createElement('div');
            temp.innerHTML = text;
            const filtered = this.filterHTMLTags(temp, ['B', 'I', 'SUB', 'SUP']);
            document.execCommand('insertHTML', false, filtered);
        });
        input.addEventListener('input', () => {
            const html = input.innerHTML.trim() === '' || input.innerHTML === '<br>' ? '' : input.innerHTML;
            this.tableState.updateRow(rowId, { assignment: html });
            // Clear error on input (real-time clearing, no new errors shown)
            this.validationState.clearError(`assignment-${rowId}`);
        });
        input.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                if (e.shiftKey) {
                    const prevRow = row.previousElementSibling;
                    if (prevRow) {
                        const prevAssignment = prevRow.querySelector('.assignment-input');
                        prevAssignment === null || prevAssignment === void 0 ? void 0 : prevAssignment.focus();
                    }
                }
                else {
                    const nextRow = row.nextElementSibling;
                    if (nextRow && !nextRow.classList.contains('add-row-footer')) {
                        const nextAssignment = nextRow.querySelector('.assignment-input');
                        nextAssignment === null || nextAssignment === void 0 ? void 0 : nextAssignment.focus();
                    }
                    else {
                        // Last row: add new row
                        const newId = this.tableState.addRow();
                        requestAnimationFrame(() => {
                            const newRow = this.rowElements.get(newId);
                            if (newRow) {
                                const newAssignment = newRow.querySelector('.assignment-input');
                                newAssignment === null || newAssignment === void 0 ? void 0 : newAssignment.focus();
                            }
                        });
                    }
                }
            }
            else if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                // Check if ArrowDown at last row
                if (e.key === 'ArrowDown') {
                    const isLastRow = !row.nextElementSibling || row.nextElementSibling.classList.contains('add-row-footer');
                    if (isLastRow) {
                        e.preventDefault();
                        const newId = this.tableState.addRow();
                        requestAnimationFrame(() => {
                            const newRow = this.rowElements.get(newId);
                            if (newRow) {
                                const nextAssignment = newRow.querySelector('.assignment-input');
                                nextAssignment === null || nextAssignment === void 0 ? void 0 : nextAssignment.focus();
                            }
                        });
                        return;
                    }
                }
                // Check if ArrowRight at end of text
                if (e.key === 'ArrowRight') {
                    const selection = window.getSelection();
                    if (selection && selection.rangeCount > 0) {
                        const isAtEnd = this.isCaretAtEnd(input);
                        if (isAtEnd) {
                            e.preventDefault();
                            const nextRow = row.nextElementSibling;
                            if (nextRow && !nextRow.classList.contains('add-row-footer')) {
                                const nextShift = nextRow.querySelector('.shift-input');
                                nextShift === null || nextShift === void 0 ? void 0 : nextShift.focus();
                            }
                            else {
                                // Last row: add new row
                                const newId = this.tableState.addRow();
                                requestAnimationFrame(() => {
                                    const newRow = this.rowElements.get(newId);
                                    if (newRow) {
                                        const firstInput = newRow.querySelector('.shift-input');
                                        firstInput === null || firstInput === void 0 ? void 0 : firstInput.focus();
                                    }
                                });
                            }
                            return;
                        }
                    }
                }
                // Handle arrow key navigation for contenteditable
                this.keyboardNav.handleCellNavigation(e, input, row, (direction) => {
                    this.keyboardNav.navigateToCell(row, input, direction);
                });
            }
            // Keyboard shortcuts
            if (e.ctrlKey || e.metaKey) {
                if (e.key === 'b' || e.key === 'B') {
                    e.preventDefault();
                    document.execCommand('bold');
                }
                else if (e.key === 'i' || e.key === 'I') {
                    e.preventDefault();
                    document.execCommand('italic');
                }
            }
        });
        // Ensure placeholder shows when field is empty on blur
        input.addEventListener('blur', () => {
            var _a;
            const text = ((_a = input.textContent) === null || _a === void 0 ? void 0 : _a.trim()) || '';
            if (text === '') {
                input.innerHTML = '';
            }
        });
    }
    setupDeleteButton(button, rowId) {
        button.addEventListener('click', (e) => {
            e.preventDefault();
            this.tableState.removeRows([rowId]);
        });
    }
    focusNextTableCell(currentInput, currentRow, reverse) {
        const currentCell = currentInput.closest('td');
        if (!currentCell)
            return;
        const cellIndex = Array.from(currentRow.children).indexOf(currentCell);
        if (reverse) {
            // Move up
            let searchRow = currentRow.previousElementSibling;
            while (searchRow) {
                const targetCell = searchRow.children[cellIndex];
                if (targetCell) {
                    const targetInput = targetCell.querySelector('input:not([disabled]), [contenteditable="true"]');
                    if (targetInput && !targetInput.disabled) {
                        targetInput.focus();
                        return;
                    }
                }
                searchRow = searchRow.previousElementSibling;
            }
        }
        else {
            // Move down
            let searchRow = currentRow.nextElementSibling;
            while (searchRow) {
                const targetCell = searchRow.children[cellIndex];
                if (targetCell) {
                    const targetInput = targetCell.querySelector('input:not([disabled]), [contenteditable="true"]');
                    if (targetInput && !targetInput.disabled) {
                        targetInput.focus();
                        return;
                    }
                }
                searchRow = searchRow.nextElementSibling;
            }
            // No cell below: add new row
            const newId = this.tableState.addRow();
            requestAnimationFrame(() => {
                const newRow = this.rowElements.get(newId);
                if (newRow) {
                    const targetCell = newRow.children[cellIndex];
                    const targetInput = targetCell === null || targetCell === void 0 ? void 0 : targetCell.querySelector('input:not([disabled]), [contenteditable="true"]');
                    if (targetInput && !targetInput.disabled) {
                        targetInput.focus();
                    }
                    else {
                        // Find first enabled input
                        const firstInput = newRow.querySelector('input:not([disabled]), [contenteditable="true"]');
                        firstInput === null || firstInput === void 0 ? void 0 : firstInput.focus();
                    }
                }
            });
        }
    }
    updateJInputsForRow(row, jValues) {
        const jInputs = row.querySelectorAll('.j-input:not([disabled])');
        jInputs.forEach((input, index) => {
            if (index < jValues.length) {
                input.value = jValues[index].toString();
            }
        });
    }
    updateJColumnVisibility() {
        const rows = this.tableState.getRows();
        // Calculate required J columns for each row
        const rowRequirements = [];
        rows.forEach(rowData => {
            const required = this.calculateRequiredJColumns(rowData.multiplicity);
            rowRequirements.push(required);
        });
        // Determine table-wide maximum
        const tableMaxJ = Math.max(0, ...rowRequirements);
        this.maxJColumns = tableMaxJ;
        // Update visibility for all rows
        this.rowElements.forEach((tr, rowId) => {
            const rowData = rows.find(r => r.id === rowId);
            if (!rowData)
                return;
            const jCells = tr.querySelectorAll('.j-input-cell');
            const requiredForRow = this.calculateRequiredJColumns(rowData.multiplicity);
            jCells.forEach((cell, cellIndex) => {
                const input = cell.querySelector('.j-input');
                if (cellIndex < requiredForRow) {
                    // Active cell
                    cell.style.display = '';
                    cell.classList.remove('disabled');
                    if (input)
                        input.disabled = false;
                }
                else if (cellIndex < tableMaxJ) {
                    // Placeholder cell
                    cell.style.display = '';
                    cell.classList.add('disabled');
                    if (input)
                        input.disabled = true;
                }
                else {
                    // Hidden cell
                    cell.style.display = 'none';
                    if (input)
                        input.disabled = true;
                }
            });
        });
        this.updateTableHeader();
        // Re-render footer to update colspan based on new maxJColumns
        this.renderAddRowFooter();
    }
    calculateRequiredJColumns(multiplicity) {
        if (!multiplicity || multiplicity.trim() === '') {
            return 0;
        }
        const multiplicityText = this.convertMultiplicityToText(multiplicity.trim());
        try {
            const jCounts = window.multipletnumbers(multiplicityText);
            if (jCounts === null) {
                return 0;
            }
            return jCounts.length;
        }
        catch (_a) {
            return 0;
        }
    }
    convertMultiplicityToText(input) {
        if (!input || input.trim() === '')
            return '';
        const trimmed = input.trim();
        if (/^\d+$/.test(trimmed)) {
            const digitMap = {
                '1': 's',
                '2': 'd',
                '3': 't',
                '4': 'q',
                '5': 'quint'
            };
            let result = '';
            for (const digit of trimmed) {
                if (digit >= '1' && digit <= '5') {
                    result += digitMap[digit];
                }
            }
            return result;
        }
        return trimmed;
    }
    updateTableHeader() {
        const thead = this.tableElement.querySelector('thead tr');
        if (!thead)
            return;
        // Remove existing J headers
        const existingJHeaders = thead.querySelectorAll('.j-header');
        existingJHeaders.forEach(header => header.remove());
        // Add J headers before Integration
        const intHeader = thead.querySelector('.integration-header');
        if (intHeader) {
            for (let i = 0; i < this.maxJColumns; i++) {
                const jHeader = document.createElement('th');
                jHeader.className = 'j-header';
                jHeader.textContent = `J${i + 1} (Hz)`;
                intHeader.insertAdjacentElement('beforebegin', jHeader);
            }
        }
    }
    isCaretAtEnd(element) {
        const selection = window.getSelection();
        if (!selection || selection.rangeCount === 0)
            return false;
        const range = selection.getRangeAt(0);
        // Check if selection is collapsed (cursor, not selection)
        if (!range.collapsed)
            return false;
        // Create a range from current position to end of element
        const testRange = document.createRange();
        testRange.selectNodeContents(element);
        testRange.setStart(range.endContainer, range.endOffset);
        // If range is empty, we're at the end
        return testRange.toString().length === 0;
    }
    filterHTMLTags(element, allowedTags) {
        let result = '';
        element.childNodes.forEach(node => {
            if (node.nodeType === Node.TEXT_NODE) {
                result += node.textContent;
            }
            else if (node.nodeType === Node.ELEMENT_NODE) {
                const tagName = node.tagName.toUpperCase();
                if (allowedTags.includes(tagName)) {
                    result += `<${tagName.toLowerCase()}>${this.filterHTMLTags(node, allowedTags)}</${tagName.toLowerCase()}>`;
                }
                else {
                    result += this.filterHTMLTags(node, allowedTags);
                }
            }
        });
        return result;
    }
    getFirstInput() {
        const firstRow = this.tableBody.querySelector('tr');
        if (firstRow) {
            return firstRow.querySelector('.shift-input');
        }
        return null;
    }
}

/**
 * Rich Text Editor Component
 * Displays formatted NMR text output
 */
class RichTextEditor {
    constructor() {
        this.element = document.getElementById('rich-text-editor');
    }
    setContent(html) {
        this.element.innerHTML = html;
    }
    getContent() {
        return this.element.innerHTML;
    }
    clear() {
        this.element.innerHTML = '';
    }
    showPlaceholder(message = 'No valid peaks to display. Add peak data in the table above.') {
        this.element.innerHTML = `<span style="color: #999;">${message}</span>`;
    }
    showError(message) {
        this.element.innerHTML = `<span style="color: red;">Error: ${message}</span>`;
    }
}

/**
 * Formatting Toolbar Component
 * Handles bold, italic, subscript, superscript, and en-dash formatting
 */
class Toolbar {
    constructor() {
        this.buttons = {
            bold: document.getElementById('format-bold-btn'),
            italic: document.getElementById('format-italic-btn'),
            sub: document.getElementById('format-sub-btn'),
            sup: document.getElementById('format-sup-btn'),
            endash: document.getElementById('insert-endash-btn')
        };
        this.initializeEventListeners();
    }
    initializeEventListeners() {
        // Use mousedown to prevent blur on contenteditable fields
        this.buttons.bold.addEventListener('mousedown', (e) => {
            e.preventDefault();
            this.applyFormatting('bold');
        });
        this.buttons.italic.addEventListener('mousedown', (e) => {
            e.preventDefault();
            this.applyFormatting('italic');
        });
        this.buttons.sub.addEventListener('mousedown', (e) => {
            e.preventDefault();
            this.applyFormatting('subscript');
        });
        this.buttons.sup.addEventListener('mousedown', (e) => {
            e.preventDefault();
            this.applyFormatting('superscript');
        });
        this.buttons.endash.addEventListener('mousedown', (e) => {
            e.preventDefault();
            this.insertEnDash();
        });
    }
    applyFormatting(command) {
        const activeElement = document.activeElement;
        if (!activeElement || activeElement.getAttribute('contenteditable') !== 'true') {
            return;
        }
        const selection = window.getSelection();
        if (selection && selection.rangeCount > 0) {
            document.execCommand(command, false);
            activeElement.focus();
        }
    }
    insertEnDash() {
        const activeElement = document.activeElement;
        if (!activeElement || activeElement.getAttribute('contenteditable') !== 'true') {
            return;
        }
        document.execCommand('insertHTML', false, '–');
        activeElement.focus();
    }
}

// ========== NAVIGATION ==========
/**
 * Focus Manager
 * Manages focus order and navigation between form fields
 */
class FocusManager {
    constructor(metadataFields, onExitMetadataToTable) {
        this.metadataFields = [];
        this.metadataFields = metadataFields;
        this.onExitMetadataToTable = onExitMetadataToTable;
    }
    /**
     * Focus next metadata field (Tab navigation)
     */
    focusNextMetadataField(currentField, reverse = false) {
        const currentIndex = this.metadataFields.indexOf(currentField);
        if (currentIndex === -1)
            return;
        let targetIndex;
        if (reverse) {
            // Shift+Tab: go to previous field, or wrap to last field
            targetIndex = currentIndex > 0 ? currentIndex - 1 : this.metadataFields.length - 1;
        }
        else {
            // Tab: go to next field, or jump to table
            if (currentIndex < this.metadataFields.length - 1) {
                targetIndex = currentIndex + 1;
            }
            else {
                // Last metadata field: jump to table
                if (this.onExitMetadataToTable) {
                    this.onExitMetadataToTable();
                }
                return;
            }
        }
        const targetField = this.metadataFields[targetIndex];
        if (targetField) {
            targetField.focus();
            // Select all content on Tab navigation
            this.selectAll(targetField);
        }
    }
    /**
     * Move cursor to end of contenteditable element
     */
    moveCursorToEnd(element) {
        var _a;
        const range = document.createRange();
        const sel = window.getSelection();
        if (element.childNodes.length > 0) {
            const lastNode = element.childNodes[element.childNodes.length - 1];
            if (lastNode.nodeType === Node.TEXT_NODE) {
                range.setStart(lastNode, ((_a = lastNode.textContent) === null || _a === void 0 ? void 0 : _a.length) || 0);
            }
            else {
                range.setStartAfter(lastNode);
            }
            range.collapse(true);
            sel === null || sel === void 0 ? void 0 : sel.removeAllRanges();
            sel === null || sel === void 0 ? void 0 : sel.addRange(range);
        }
    }
    /**
     * Move cursor to start of contenteditable element
     */
    moveCursorToStart(element) {
        const range = document.createRange();
        const sel = window.getSelection();
        if (element.childNodes.length > 0) {
            range.setStart(element.childNodes[0], 0);
            range.collapse(true);
            sel === null || sel === void 0 ? void 0 : sel.removeAllRanges();
            sel === null || sel === void 0 ? void 0 : sel.addRange(range);
        }
    }
    /**
     * Select all content in contenteditable element
     */
    selectAll(element) {
        const range = document.createRange();
        const sel = window.getSelection();
        range.selectNodeContents(element);
        sel === null || sel === void 0 ? void 0 : sel.removeAllRanges();
        sel === null || sel === void 0 ? void 0 : sel.addRange(range);
    }
}

/**
 * Keyboard Navigation
 * Handles arrow key navigation within table cells and other complex navigation
 */
class KeyboardNav {
    /**
     * Handle arrow key navigation between table cells
     */
    handleCellNavigation(e, currentInput, currentRow, onNavigate) {
        const key = e.key;
        // Handle Tab navigation (handled by browser default + custom logic)
        if (key === 'Tab') {
            return; // Let default or custom Tab handlers manage this
        }
        // Arrow key navigation
        if (key === 'ArrowUp' || key === 'ArrowDown' || key === 'ArrowLeft' || key === 'ArrowRight') {
            const isContentEditable = currentInput.getAttribute('contenteditable') === 'true';
            if (isContentEditable) {
                this.handleContentEditableArrowKeys(e, currentInput, onNavigate);
            }
            else if (currentInput.type === 'number') {
                this.handleNumberInputArrowKeys(e, onNavigate);
            }
            else {
                this.handleTextInputArrowKeys(e, currentInput, onNavigate);
            }
        }
    }
    handleContentEditableArrowKeys(e, currentInput, onNavigate) {
        const selection = window.getSelection();
        const range = selection && selection.rangeCount > 0 ? selection.getRangeAt(0) : null;
        const text = currentInput.textContent || '';
        const cursorPosition = range ? range.startOffset : 0;
        if (e.key === 'ArrowUp') {
            e.preventDefault();
            onNavigate('up');
        }
        else if (e.key === 'ArrowDown') {
            e.preventDefault();
            onNavigate('down');
        }
        else if (e.key === 'ArrowRight' && cursorPosition >= text.length) {
            e.preventDefault();
            onNavigate('right');
        }
        else if (e.key === 'ArrowLeft' && cursorPosition === 0) {
            e.preventDefault();
            onNavigate('left');
        }
    }
    handleNumberInputArrowKeys(e, onNavigate) {
        // For number inputs, always override arrow keys for navigation
        if (e.key === 'ArrowUp') {
            e.preventDefault();
            onNavigate('up');
        }
        else if (e.key === 'ArrowDown') {
            e.preventDefault();
            onNavigate('down');
        }
        else if (e.key === 'ArrowRight') {
            e.preventDefault();
            onNavigate('right');
        }
        else if (e.key === 'ArrowLeft') {
            e.preventDefault();
            onNavigate('left');
        }
    }
    handleTextInputArrowKeys(e, currentInput, onNavigate) {
        const cursorPosition = currentInput.selectionStart || 0;
        const text = currentInput.value || '';
        if (e.key === 'ArrowUp') {
            e.preventDefault();
            onNavigate('up');
        }
        else if (e.key === 'ArrowDown') {
            e.preventDefault();
            onNavigate('down');
        }
        else if (e.key === 'ArrowRight' && cursorPosition >= text.length) {
            e.preventDefault();
            onNavigate('right');
        }
        else if (e.key === 'ArrowLeft' && cursorPosition === 0) {
            e.preventDefault();
            onNavigate('left');
        }
    }
    /**
     * Navigate to adjacent cell in table
     */
    navigateToCell(currentRow, currentInput, direction) {
        const currentCell = currentInput.closest('td');
        if (!currentCell)
            return;
        if (direction === 'up' || direction === 'down') {
            this.navigateVertical(currentRow, currentCell, direction);
        }
        else {
            this.navigateHorizontal(currentRow, currentCell, direction);
        }
    }
    navigateVertical(currentRow, currentCell, direction) {
        const targetRow = direction === 'up'
            ? currentRow.previousElementSibling
            : currentRow.nextElementSibling;
        if (!targetRow)
            return;
        const cellIndex = Array.from(currentRow.children).indexOf(currentCell);
        const targetCell = targetRow.children[cellIndex];
        if (targetCell) {
            const targetInput = targetCell.querySelector('input, [contenteditable="true"]');
            targetInput === null || targetInput === void 0 ? void 0 : targetInput.focus();
        }
    }
    navigateHorizontal(currentRow, currentCell, direction) {
        var _a;
        // Find all visible, enabled cells
        const allCells = Array.from(currentRow.querySelectorAll('td:not(.checkbox-cell)'));
        const visibleCells = allCells.filter(cell => {
            if (cell.style.display === 'none')
                return false;
            const input = cell.querySelector('input, [contenteditable="true"]');
            if (!input)
                return false;
            if (input.disabled)
                return false;
            return true;
        });
        const currentIndex = visibleCells.indexOf(currentCell);
        if (currentIndex === -1)
            return;
        const targetIndex = direction === 'right' ? currentIndex + 1 : currentIndex - 1;
        if (targetIndex < 0 || targetIndex >= visibleCells.length)
            return;
        const targetCell = visibleCells[targetIndex];
        const targetInput = targetCell.querySelector('input:not([disabled]), [contenteditable="true"]');
        if (targetInput) {
            targetInput.focus();
            // Set cursor position for contenteditable
            if (targetInput.getAttribute('contenteditable') === 'true') {
                const range = document.createRange();
                const sel = window.getSelection();
                const textNode = targetInput.firstChild;
                if (textNode && textNode.nodeType === Node.TEXT_NODE) {
                    if (direction === 'right') {
                        range.setStart(textNode, 0);
                    }
                    else {
                        range.setStart(textNode, ((_a = textNode.textContent) === null || _a === void 0 ? void 0 : _a.length) || 0);
                    }
                    range.collapse(true);
                    sel === null || sel === void 0 ? void 0 : sel.removeAllRanges();
                    sel === null || sel === void 0 ? void 0 : sel.addRange(range);
                }
            }
            else if (targetInput.type !== 'number') {
                // Set cursor position for text inputs
                const input = targetInput;
                if (direction === 'right') {
                    input.setSelectionRange(0, 0);
                }
                else {
                    const len = input.value.length;
                    input.setSelectionRange(len, len);
                }
            }
        }
    }
}

// ========== MAIN APPLICATION ==========
/**
 * Main Application
 * Orchestrates all components and manages application lifecycle
 */
// Import from existing modules
class NMRFormatterApp {
    constructor() {
        this.appState = new AppState();
        // Initialize focus manager
        this.focusManager = new FocusManager([], () => {
            const firstInput = this.nmrTable.getFirstInput();
            firstInput === null || firstInput === void 0 ? void 0 : firstInput.focus();
        });
        // Initialize metadata form
        this.metadataForm = new MetadataForm(this.appState.metadata, this.appState.validation, (currentField, reverse) => {
            this.focusManager.focusNextMetadataField(currentField, reverse);
        }, () => {
            // Regenerate formatted text when sort order changes
            this.generateFormattedText();
        });
        // Update focus manager with metadata fields
        this.focusManager = new FocusManager(this.metadataForm.getFieldOrder(), () => {
            const firstInput = this.nmrTable.getFirstInput();
            firstInput === null || firstInput === void 0 ? void 0 : firstInput.focus();
        });
        // Initialize NMR table
        this.nmrTable = new NMRTable(this.appState.table, this.appState.validation, () => {
            // On multiplicity change
            this.appState.validation.clearAllErrors();
        }, (reverse) => {
            var _a;
            // On navigate to metadata
            const fields = this.metadataForm.getFieldOrder();
            if (reverse) {
                (_a = fields[fields.length - 1]) === null || _a === void 0 ? void 0 : _a.focus();
            }
        });
        // Initialize rich text editor
        this.richTextEditor = new RichTextEditor();
        // Initialize toolbar
        this.toolbar = new Toolbar();
        // Initialize event listeners
        this.initializeEventListeners();
    }
    initializeEventListeners() {
        // Convert down button (Table → Rich Text)
        const convertDownBtn = document.getElementById('convert-down-btn');
        convertDownBtn === null || convertDownBtn === void 0 ? void 0 : convertDownBtn.addEventListener('click', () => {
            this.generateFormattedText();
        });
        // Copy button
        const copyBtn = document.getElementById('copy-btn');
        copyBtn === null || copyBtn === void 0 ? void 0 : copyBtn.addEventListener('click', () => {
            this.copyFormattedText();
        });
    }
    generateFormattedText() {
        try {
            // Get metadata
            const metadataData = this.appState.metadata.getData();
            const metadata = new Metadata(metadataData.nuclei, // HTML content as nuclei type
            metadataData.solvent, // HTML content as solvent type
            metadataData.frequency);
            // Sort all J-values in descending order
            this.appState.table.sortAllJValues();
            // Remove empty rows from table
            this.appState.table.removeEmptyRows();
            // Validate and highlight errors (after removing empty rows)
            const hasErrors = this.validateAndHighlightTable();
            // Get peaks from table state
            const tableRows = this.appState.table.getRows();
            const peaks = [];
            tableRows.forEach(row => {
                const shift = parseChemicalShift(row.shift);
                const multiplicity = convertMultiplicityToText(row.multiplicity);
                if (shift !== null) {
                    const peak = new NMRPeak(shift, multiplicity, row.jValues, row.integration, row.assignment);
                    peaks.push(peak);
                }
            });
            if (peaks.length === 0) {
                this.richTextEditor.showPlaceholder();
                return;
            }
            // Sort peaks by chemical shift
            sortPeaksByShift(peaks, metadataData.sortOrder);
            const nmrData = new NMRData(peaks, metadata);
            // Generate formatted text
            const generateFormattedText = window.generateFormattedText;
            const formattedText = generateFormattedText(nmrData, metadataData.shiftPrecision, metadataData.jPrecision, 0);
            this.richTextEditor.setContent(formattedText);
            if (hasErrors) {
                console.log('Generated text with validation errors present');
            }
        }
        catch (error) {
            console.error('Error generating formatted text:', error);
            this.richTextEditor.showError(error.message);
        }
    }
    validateAndHighlightTable() {
        let hasErrors = false;
        // Validate metadata
        const metadataData = this.appState.metadata.getData();
        hasErrors = validateMetadata({
            nuclei: metadataData.nuclei,
            solvent: metadataData.solvent,
            frequency: metadataData.frequency
        }, this.appState.validation);
        // Validate table rows
        const tableRows = this.appState.table.getRows();
        const is1HNMR = metadataData.nuclei.includes('1') && metadataData.nuclei.includes('H');
        if (validateTableRows(tableRows, is1HNMR, this.appState.validation)) {
            hasErrors = true;
        }
        return hasErrors;
    }
    copyFormattedText() {
        const richTextContent = this.richTextEditor.getContent();
        if (!richTextContent || richTextContent.trim() === '') {
            alert('No formatted text to copy. Generate text first.');
            return;
        }
        // Create temporary element to copy HTML content
        const tempElement = document.createElement('div');
        tempElement.innerHTML = richTextContent;
        document.body.appendChild(tempElement);
        // Select the content
        const range = document.createRange();
        range.selectNodeContents(tempElement);
        const selection = window.getSelection();
        selection === null || selection === void 0 ? void 0 : selection.removeAllRanges();
        selection === null || selection === void 0 ? void 0 : selection.addRange(range);
        try {
            // Copy to clipboard
            document.execCommand('copy');
            // Show feedback
            const copyBtn = document.getElementById('copy-btn');
            if (copyBtn) {
                const originalText = copyBtn.textContent;
                copyBtn.textContent = 'Copied!';
                copyBtn.style.backgroundColor = '#28a745';
                copyBtn.style.color = 'white';
                setTimeout(() => {
                    copyBtn.textContent = originalText || 'Copy';
                    copyBtn.style.backgroundColor = '';
                    copyBtn.style.color = '';
                }, 2000);
            }
        }
        catch (error) {
            console.error('Failed to copy:', error);
            alert('Failed to copy to clipboard');
        }
        finally {
            // Clean up
            document.body.removeChild(tempElement);
            selection === null || selection === void 0 ? void 0 : selection.removeAllRanges();
        }
    }
}
// Initialize app when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
    window.app = new NMRFormatterApp();
    console.log('NMR Formatter App initialized (TypeScript version)');
});

// Export to window object for browser usage (legacy support)
window.Logger = Logger;
window.LogLevel = LogLevel;
window.NUCLEI_PRESETS = NUCLEI_PRESETS;
window.SOLVENT_PRESETS = SOLVENT_PRESETS;
window.SORT_ORDER_PRESETS = SORT_ORDER_PRESETS;
window.NUCLEI_CONFIG = NUCLEI_CONFIG;
window.SOLVENT_CONFIG = SOLVENT_CONFIG;
window.getNucleiPatterns = getNucleiPatterns;
window.getSolventPatterns = getSolventPatterns;
window.extractNucleiFromText = extractNucleiFromText;
window.extractSolventFromText = extractSolventFromText;
window.isValidNucleiType = isValidNucleiType;
window.isValidSolventType = isValidSolventType;
window.Metadata = Metadata;
window.NMRPeak = NMRPeak;
window.NMRData = NMRData;
window.multipletnumbers = NMRPeak.multipletnumbers;
window.formatChemicalShift = formatChemicalShift;
window.formatJValues = formatJValues;
window.formatIntegration = formatIntegration;
window.formatMultiplicity = formatMultiplicity;
window.formatAssignment = formatAssignment;
window.formatSinglePeak = formatSinglePeak;
window.formatMetadata = formatMetadata;
window.generateFormattedText = generateFormattedText;
window.isJValuesOptional = NMRPeak.isJValuesOptional;

// Export new classes (State Management & UI)
window.MetadataState = MetadataState;
window.TableState = TableState;
window.ValidationState = ValidationState;
window.AppState = AppState;
window.MetadataForm = MetadataForm;
window.NMRTable = NMRTable;
window.RichTextEditor = RichTextEditor;
window.Toolbar = Toolbar;
window.FocusManager = FocusManager;
window.KeyboardNav = KeyboardNav;
window.NMRFormatterApp = NMRFormatterApp;

console.log('NMR Formatter browser bundle loaded (TypeScript refactored version)');
